<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIYANO // PRODUCT_DESIGN</title>
    <meta name="description" content="Product Design com foco em impacto: casos Algar Telecom e Volpi com métricas, pesquisa e execução." />
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
        "three/": "https://unpkg.com/three@0.128.0/"
      }
    }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050505;
            --surface: #0f0f0f;
            --accent: #00ff88; /* Bright Green */
            --accent-glow: rgba(0, 255, 136, 0.3);
            --text-main: #ffffff;
            --text-dim: #888;
            --border: #222;
            --font-main: 'Inter', sans-serif;
        }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: var(--font-main);
            overflow-x: hidden;
            line-height: 1.5;
            position: relative;
        }

        /* Ambient Lighting Effects */


        .bg-noise {
            position: fixed;
            inset: 0;
            z-index: 5;
            opacity: 0.05;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3BaseFilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
        }

        /* Ensure content sits above background layers */
        main {
            position: relative;
            z-index: 10;
        }

        @keyframes kineticDrift {
            0% { background-position: 0 0; }
            100% { background-position: 60px 60px; }
        }

        .mono { font-family: 'JetBrains Mono', monospace; }

        /* Floating Nav - Optimized */
        .hud-nav {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(0);
            z-index: 1000;
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 1;
        }

        .hud-nav.nav-hidden {
            opacity: 0;
            transform: translateX(-50%) translateY(-40px);
            pointer-events: none;
        }

        .hud-nav:hover {
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
        }
        
        .logo-box {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }
        .logo-mark {
            width: 12px;
            height: 12px;
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }
        .logo-text {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.1em;
            color: var(--text-main);
            text-transform: uppercase;
        }

        .nav-links {
            display: flex;
            padding: 0 8px;
        }

        .hud-link {
            font-family: 'JetBrains Mono';
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            padding: 8px 16px;
            text-decoration: none;
            transition: color 0.2s;
        }
        .hud-link:hover { color: var(--accent); }

        /* Grid Layout */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 40px;
        }

        /* Hero */
        .hero-section {
            height: 100vh;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 10;
            overflow: hidden;
        }

        .bg-hero-container {
            position: absolute;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background: #000;
        }

        #bg-wave-canvas, #bg-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #bg-wave-canvas {
            opacity: 0.6;
            z-index: 0;
        }

        #bg-canvas {
            z-index: 1;
            pointer-events: auto; /* Allow dragging cubes */
        }

        .bg-vignette {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, transparent 0%, var(--bg) 95%);
            z-index: 2;
            pointer-events: none;
        }
        .hero-title {
            font-family: 'JetBrains Mono';
            font-size: 6vw;
            line-height: 0.9;
            letter-spacing: -0.05em;
            text-transform: uppercase;
            font-weight: 800;
        }
        .badge {
            display: inline-block;
            padding: 4px 0;
            font-size: 10px;
            color: var(--accent);
            letter-spacing: 0.1em;
            margin-bottom: 24px;
            font-family: 'JetBrains Mono';
        }

        /* Works Grid - Bento Box Layout */
        .work-bento {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 20px;
            margin-bottom: 80px;
        }

        .work-card {
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.4) 0%, rgba(10, 10, 10, 0.3) 100%);
            backdrop-filter: blur(40px) saturate(140%);
            border: 2px solid;
            border-color: rgba(255, 255, 255, 0.15);
            transition: all 0.5s cubic-bezier(0.2, 0.9, 0.3, 1);
            min-height: 420px;
            display: flex;
            flex-direction: column;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 2px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
        }

        .work-card.featured {
            grid-column: span 12;
            min-height: 520px;
        }

        .work-card.medium {
            grid-column: span 6;
            min-height: 460px;
        }

        /* Ensure all cards have identical glass properties */
        .work-card.featured,
        .work-card.medium {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.4) 0%, rgba(10, 10, 10, 0.3) 100%);
            backdrop-filter: blur(40px) saturate(140%);
            border: 2px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 2px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
        }

        .card-link {
            display: flex;
            flex-direction: column;
            height: 100%;
            text-decoration: none;
            color: inherit;
            position: relative;
            z-index: 1;
            padding: 40px;
        }

        .card-bg {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            transition: transform 0.6s cubic-bezier(0.2, 0.9, 0.3, 1), filter 0.4s ease, opacity 0.4s ease;
            filter: brightness(0.5) saturate(0.7);
            opacity: 0.5;
            z-index: 0;
        }

        .work-card:hover .card-bg {
            transform: scale(1.05);
            filter: brightness(0.6) saturate(0.9);
            opacity: 0.6;
        }

        .card-index {
            font-family: 'JetBrains Mono', monospace;
            font-size: 120px;
            font-weight: 900;
            line-height: 1;
            color: rgba(0,255,136,0.08);
            position: absolute;
            top: 20px;
            right: 30px;
            z-index: 1;
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .work-card:hover .card-index {
            color: rgba(0,255,136,0.14);
            transform: translateY(-8px);
        }

        .card-content {
            position: relative;
            z-index: 2;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card-meta {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent);
            font-weight: 600;
        }

        .card-title {
            font-size: 2.8rem;
            font-weight: 900;
            line-height: 0.95;
            letter-spacing: -0.03em;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .work-card.medium .card-title {
            font-size: 2.2rem;
        }

        .card-excerpt {
            font-size: 1rem;
            line-height: 1.6;
            color: #d4d4d4;
            max-width: 600px;
            margin-bottom: 24px;
        }

        .work-card.medium .card-excerpt {
            font-size: 0.92rem;
        }

        .card-metrics {
            display: flex;
            gap: 32px;
            margin-top: auto;
            padding-top: 24px;
        }

        .card-metrics.compact {
            gap: 24px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent);
            line-height: 1;
        }

        .work-card.medium .metric-value {
            font-size: 1.4rem;
        }

        .metric-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
        }

        .card-cta {
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--accent);
            font-weight: 600;
        }

        .card-3d-viz {
            display: block !important;
            opacity: 0.8;
        }

        .cta-arrow {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .work-card:hover .cta-arrow {
            transform: translateX(8px);
        }

        .work-card:hover {
            border-color: rgba(0, 255, 136, 0.5);
            transform: translateY(-10px) scale(1.01);
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.5) 0%, rgba(20, 20, 20, 0.4) 100%);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.9),
                0 8px 32px rgba(0, 255, 136, 0.2),
                0 0 80px rgba(0, 255, 136, 0.1),
                inset 0 2px 2px rgba(255, 255, 255, 0.5),
                inset 0 -3px 6px rgba(0, 0, 0, 0.7);
        }

        .card-3d-viz {
            position: absolute;
            inset: 0;
            z-index: 5;
            pointer-events: none;
            display: block !important;
            opacity: 1;
        }

        @media (max-width: 768px) {
            .work-card.featured,
            .work-card.medium {
                grid-column: span 12;
                min-height: 380px;
            }
            .card-link { padding: 28px; }
            .card-title { font-size: 2rem; }
            .card-index { font-size: 80px; top: 10px; right: 20px; }
        }

        /* Particles canvas overlay */
        #bg-particles {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* Reveal on scroll */
        .reveal { opacity: 0; transform: translateY(14px) scale(0.996); transition: opacity 0.6s ease, transform 0.6s cubic-bezier(.2,.9,.3,1); }
        .reveal.visible { opacity: 1; transform: translateY(0) scale(1); }

        /* Section headings */
        .section-heading { position: relative; }

        /* Node Graph */
        #node-graph-viz {
            width: 100%;
            height: 800px;
            background: transparent;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .graph-loading {
            font-family: 'JetBrains Mono';
            font-size: 12px;
            color: var(--accent);
            letter-spacing: 0.1em;
        }

        #bg-canvas {
            position: absolute;
            top: 0; right: 0; width: 100%; height: 100%;
            z-index: 0;
        }

        footer {
            padding: 160px 40px; /* Even more space for the wave */
            background: #050505;
            position: relative;
        }

        footer .grid-container { display: flex; align-items: center; justify-content: center; }
        footer .contact-inner { text-align: center; max-width: 900px; margin: 0 auto; }
        
        .contact-content-wrapper {
            padding: 80px 0;
            margin: 40px 0;
        }

        .contact-content h2 {
            font-family: 'JetBrains Mono', monospace;
            line-height: 0.9;
        }

        .contact-card:hover {
            border-color: rgba(0, 255, 136, 0.5);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.9),
                0 8px 32px rgba(0, 255, 136, 0.2),
                0 0 80px rgba(0, 255, 136, 0.1),
                inset 0 2px 2px rgba(255, 255, 255, 0.5),
                inset 0 -3px 6px rgba(0, 0, 0, 0.7);
            transform: translateY(-8px);
        }

        .contact-content h2 {
            font-size: 3.5rem;
            font-weight: 900;
            line-height: 1;
            letter-spacing: -0.02em;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #ffffff 0%, #888888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .contact-content p {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #d4d4d4;
            margin: 20px 0;
        }

        .contact-cta-row { display:flex; gap:20px; align-items:center; justify-content:center; margin-top:40px; flex-wrap: wrap; }

        .btn-primary {
            padding: 16px 32px;
            background: linear-gradient(90deg, #00ff88, #00d18f);
            color: #012;
            font-weight: 700;
            font-size: 1rem;
            box-shadow: 0 8px 30px var(--accent-glow);
            border: none;
            transition: all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1);
            text-decoration: none;
            display:inline-flex;
            align-items:center;
            gap:10px;
            cursor: pointer;
        }
        .btn-primary:hover { 
            transform: translateY(-6px) scale(1.05);
            box-shadow: 0 16px 50px var(--accent-glow);
            opacity:0.95; 
        }

        .contact-btn { 
            display: inline-flex; 
            align-items:center; 
            justify-content:center; 
            width:100px; 
            height:100px; 
            background: transparent;
            border: none;
            transition: all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1); 
            color: var(--accent);
            position: relative;
        }
        .ico-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .contact-btn svg { 
            position: relative;
            z-index: 1;
            width:22px; 
            height:22px; 
            fill:currentColor; 
            transition: transform 0.4s ease;
        }
        .contact-btn:hover svg { 
            transform: scale(1.2) rotate(5deg);
        }

        @media (max-width: 768px) {
            .hero-title { font-size: 3rem; }
            .contact-card { padding: 40px 24px; }
            .contact-content h2 { font-size: 2.5rem; }
            .contact-cta-row { gap: 12px; }
        }
    </style>
</head>
<body>
    <div class="bg-noise"></div>

    <nav class="hud-nav">
        <div class="logo-box">
            <div class="logo-mark"></div>
            <span class="logo-text mono">MIYANO</span>
        </div>
        <div class="nav-links">
            <a href="#" class="hud-link">About</a>
            <a href="#work" class="hud-link">Work</a>
            <a href="#contact" class="hud-link">Contact</a>
        </div>
    </nav>

    <main class="relative z-10">
        <!-- Hero -->
        <section class="hero-section">
            <div class="bg-hero-container">
                <div id="bg-canvas"></div>
                <div class="bg-vignette"></div>
            </div>
            <div class="grid-container w-full relative z-10 pointer-events-none">
                <div class="col-span-12 md:col-span-8 pointer-events-auto">
                    <div class="badge mono">WHO?</div>
                    <h1 class="hero-title">
                        PRODUCT <br>
                        DESIGN
                    </h1>
                    <p class="mt-6 text-neutral-200 max-w-lg text-lg leading-relaxed font-light">
                        I turn complex problems into experiences people actually remember.
                    </p>
                    <p class="mt-4 text-neutral-500 max-w-md text-sm italic">
                        Forget "delight". Let's build utility with soul.
                    </p>
                    <div class="mt-8">
                        <a href="#work" class="inline-block bg-white text-black px-6 py-3 font-bold text-sm uppercase tracking-wide hover:bg-neutral-200 transition-colors">SEE WORK ↓</a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Projects -->
        <section id="work" class="py-32 relative overflow-hidden">
            <div class="max-w-[1400px] mx-auto px-8">
                <div class="mb-24 text-center">
                    <h2 class="mono text-xs text-neutral-500 tracking-[0.2em] uppercase mb-4">SELECTED WORK</h2>
                    <p class="text-neutral-400 text-sm max-w-md mx-auto">Three systems. Real impact. No BS.</p>
                </div>

                <!-- Bento Grid -->
                <div class="work-bento">
                    <!-- Featured: Algar (Large) -->
                    <article class="work-card featured" data-index="01">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(5,5,5,0.8)), url('assets/algar/hero.png'); background-position: center 25%; background-size: cover; z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="phone" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/algar.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">01</div>
                            <div class="card-content">
                                <span class="card-meta">Telecom / UX Performance</span>
                                <h3 class="card-title">ALGAR TELECOM</h3>
                                <p class="card-excerpt">Took a 1.9-star app to 3.0 by fixing what actually mattered: Login & Payments. No fluff.</p>
                                <div class="card-metrics">
                                    <div class="metric">
                                        <span class="metric-value">1.9 → 3.0</span>
                                        <span class="metric-label">App Rating</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">-42%</span>
                                        <span class="metric-label">Support Tickets</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Volpi (Medium) -->
                    <article class="work-card medium" data-index="02">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(15,5,25,0.92), rgba(5,5,5,0.88)), url('assets/volpi/thumb.svg'); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="building" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/volpi.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">02</div>
                            <div class="card-content">
                                <span class="card-meta">Fintech / Strategy</span>
                                <h3 class="card-title">VOLPI</h3>
                                <p class="card-excerpt">Turned home financing from a black box into a transparent checklist.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">-40%</span>
                                        <span class="metric-label">Process Time</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">+35%</span>
                                        <span class="metric-label">Conversion</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Torre (Medium) -->
                    <article class="work-card medium" data-index="03">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(20,10,5,0.92), rgba(5,5,5,0.88)), url('assets/torre/flow-1.svg'); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="truck" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/torre-controle.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">03</div>
                            <div class="card-content">
                                <span class="card-meta">Logistics / B2B</span>
                                <h3 class="card-title">TORRE DE CONTROLE</h3>
                                <p class="card-excerpt">Command center that routes 10k+ shipments. Real-time visibility meets workflow automation.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">-30%</span>
                                        <span class="metric-label">MTTR</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">50%</span>
                                        <span class="metric-label">Auto-routed</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>
                </div>
            </div>
        </section>



        <!-- Systems Thinking -->
        <section class="py-32">
            <div class="grid-container">
                <div class="col-span-12 text-center mb-16">
                    <h2 class="mono text-xs text-neutral-500 tracking-[0.2em] uppercase mb-8 section-heading reveal">SYSTEMS THINKING</h2>
                    <blockquote class="text-xl md:text-2xl text-neutral-200 font-light max-w-3xl mx-auto leading-relaxed">
                        "THE SYSTEM IS MORE THAN THE SUM OF ITS PARTS. <br>
                        <span class="text-neutral-500">IT IS THE PRODUCT OF THEIR INTERACTIONS."</span>
                    </blockquote>
                </div>
                <div class="col-span-12">
                    <div id="node-graph-viz">
                        <div class="graph-loading">[INITIALIZING_GRAPH...]</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Contact/Footer -->
        <footer id="contact" class="relative overflow-hidden">
            <div class="bg-hero-container">
                <canvas id="bg-wave-canvas"></canvas>
                <div class="bg-vignette"></div>
            </div>
            <div class="grid-container relative z-10">
                <div class="col-span-12 contact-inner">
                    <div class="contact-content-wrapper">
                        <div class="contact-content">
                            <h2 class="text-5xl md:text-7xl font-bold tracking-tighter mb-8">LET'S CREATE<br>SOMETHING GREAT</h2>
                            <p class="text-xl text-neutral-300 max-w-2xl mx-auto mb-4">Got an idea? A project? Or just want to chat about design and technology?</p>
                            <p class="mono text-accent text-sm tracking-widest uppercase">I'm always up for a conversation.</p>
                        </div>

                        <div class="contact-cta-row mt-12">
                            <a href="https://www.linkedin.com/" class="contact-btn ico-btn" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer" title="LINKEDIN">
                                <canvas class="ico-canvas"></canvas>
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4.98 3.5C4.98 4.88 3.86 6 2.5 6S0 4.88 0 3.5 1.12 1 2.5 1 4.98 2.12 4.98 3.5zM0 8.99h5V24H0V8.99zM8.5 8.99h4.78v2.07h.07c.67-1.27 2.3-2.61 4.74-2.61 5.07 0 6 3.34 6 7.68V24h-5v-7.52c0-1.79-.03-4.09-2.49-4.09-2.49 0-2.87 1.94-2.87 3.96V24h-5V8.99z"/></svg>
                            </a>
                            <a href="mailto:hello@miyano.net" class="contact-btn ico-btn" aria-label="Email">
                                <canvas class="ico-canvas"></canvas>
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z" fill="currentColor"/></svg>
                            </a>
                        </div>
                    </div>

                    <div style="margin-top: 60px; padding-top: 40px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                        <p class="mono text-[10px] text-neutral-600 mb-2">© 2026 Miyano Bot.</p>
                        <p class="mono text-xs opacity-40">No rights reserved. Copy this if you want.</p>
                    </div>
                </div>
            </div>
        </footer>
    </main>

    <script>
        // Dynamic Nav - Show/Hide on scroll
        const nav = document.querySelector('.hud-nav');
        let lastScrollY = window.scrollY;
        let ticking = false;

        function updateNav() {
            const currentScrollY = window.scrollY;
            const scrollingDown = currentScrollY > lastScrollY;
            const scrollingUp = currentScrollY < lastScrollY;

            // Hide when scrolling down, show when scrolling up
            if (scrollingDown && currentScrollY > 100) {
                nav.classList.add('nav-hidden');
            } else if (scrollingUp) {
                nav.classList.remove('nav-hidden');
            }

            // Always show at very top
            if (currentScrollY < 50) {
                nav.classList.remove('nav-hidden');
            }

            lastScrollY = currentScrollY;
            ticking = false;
        }

        window.addEventListener('scroll', () => {
            if (!ticking) {
                window.requestAnimationFrame(updateNav);
                ticking = true;
            }
        }, { passive: true });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'https://unpkg.com/three@0.128.0/examples/jsm/geometries/RoundedBoxGeometry.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
        import { MeshSurfaceSampler } from 'https://unpkg.com/three@0.128.0/examples/jsm/math/MeshSurfaceSampler.js';

        // Audio Engine (keeping in module scope or attaching to window)
        window.AUDIO = {
            ctx: null,
            init() { 
                if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            },
            play(freq) {
                this.init();
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.frequency.value = freq;
                o.type = 'sine';
                g.gain.setValueAtTime(0.02, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                o.connect(g);
                g.connect(this.ctx.destination);
                o.start();
                o.stop(this.ctx.currentTime + 0.1);
            }
        };

        // UI Interactions
        document.querySelectorAll('a, .work-card').forEach(el => {
            el.addEventListener('mouseenter', () => window.AUDIO.play(2000));
        });

        // 3D Particle Visualizations on Work Cards
        (function init3DViz() {
            console.log('Initializing 3D visualizations...');
            
            // Helper: Generate phone shape as 3D points
            function generatePhonePoints() {
                const points = [];
                const w = 70, h = 140, d = 10, r = 12;
                const density = 2.5;
                
                // Front and Back faces with rounded corners
                for (let x = -w/2; x <= w/2; x += density) {
                    for (let y = -h/2; y <= h/2; y += density) {
                        const dx = Math.abs(x) - (w/2 - r);
                        const dy = Math.abs(y) - (h/2 - r);
                        let inside = false;
                        if (dx <= 0 || dy <= 0) inside = true;
                        else if (dx * dx + dy * dy <= r * r) inside = true;

                        if (inside) {
                            // Bezel vs Screen logic
                            const margin = 4;
                            const isScreen = Math.abs(x) < (w/2 - margin) && Math.abs(y) < (h/2 - margin);
                            
                            // Front face (Screen has higher density)
                            if (isScreen) {
                                // Dynamic Island cutout
                                const isIsland = Math.abs(x) < 12 && y > h/2 - 15 && y < h/2 - 10;
                                if (!isIsland) points.push([x, y, d/2]);
                            } else {
                                points.push([x, y, d/2]);
                            }

                            // Back face
                            const isCameraBump = x < -w/2 + 30 && y > h/2 - 40;
                            if (isCameraBump) {
                                points.push([x, y, -d/2 - 2]); // Camera bump sticking out
                                // Lenses
                                const l1 = Math.pow(x - (-w/2 + 12), 2) + Math.pow(y - (h/2 - 12), 2) < 16;
                                const l2 = Math.pow(x - (-w/2 + 12), 2) + Math.pow(y - (h/2 - 28), 2) < 16;
                                if (l1 || l2) points.push([x, y, -d/2 - 4]);
                            } else {
                                // Algar Logo on the back
                                const logoX = 0, logoY = -10, logoSize = 15;
                                const distFromLogoCenter = Math.sqrt(Math.pow(x - logoX, 2) + Math.pow(y - logoY, 2));
                                const isLogo = distFromLogoCenter < logoSize && distFromLogoCenter > logoSize - 3;
                                const isLogoInner = Math.abs(x) < 2 && Math.abs(y - logoY) < logoSize;
                                
                                if (isLogo || isLogoInner) {
                                    points.push([x, y, -d/2 - 1.5]);
                                } else {
                                    if (Math.random() > 0.6) points.push([x, y, -d/2]);
                                }
                            }
                        }
                    }
                }
                
                // Sides/Edges
                for (let y = -h/2; y <= h/2; y += density * 1.5) {
                    const dy = Math.abs(y) - (h/2 - r);
                    const curX = dy > 0 ? (w/2 - r) + Math.sqrt(Math.max(0, r*r - dy*dy)) : w/2;
                    for (let z = -d/2; z <= d/2; z += density) {
                        points.push([curX, y, z]);
                        points.push([-curX, y, z]);
                    }
                }
                
                return points;
            }
            
            // Helper: Generate realistic house shape
            function generateBuildingPoints() {
                const points = [];
                const density = 2.4;
                
                const drawStructure = (xOff, yOff, zOff, w, h, d, hasRoof = true) => {
                    for (let x = -w/2; x <= w/2; x += density) {
                        for (let y = -h/2; y <= h/2; y += density) {
                            for (let z = -d/2; z <= d/2; z += density) {
                                const isSurface = Math.abs(x - w/2) < 1 || Math.abs(x + w/2) < 1 || 
                                                 Math.abs(y - h/2) < 1 || Math.abs(y + h/2) < 1 || 
                                                 Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1;
                                if (isSurface) {
                                    // Main Door
                                    const isFront = Math.abs(z - d/2) < 1 && xOff === 0;
                                    const isDoor = isFront && Math.abs(x) < 8 && y < -5;
                                    if (isDoor) continue;
                                    
                                    // Windows
                                    const isWindow = (Math.abs(x) % 30 > 8 && Math.abs(x) % 30 < 22 && Math.abs(y) < 10);
                                    if (isWindow && !isDoor) continue;

                                    points.push([x + xOff, y + yOff, z + zOff]);
                                }
                            }
                        }
                    }
                    if (hasRoof) {
                        const roofH = 35;
                        for (let z = -d/2 - 4; z <= d/2 + 4; z += density) {
                            for (let x = -w/2 - 4; x <= w/2 + 4; x += density) {
                                const ry = h/2 + roofH * (1 - Math.abs(x) / (w/2 + 4));
                                points.push([x + xOff, ry + yOff, z + zOff]);
                                if (Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1) {
                                    for (let gy = h/2; gy < ry; gy += density) {
                                        points.push([x + xOff, gy + yOff, z + zOff]);
                                    }
                                }
                            }
                        }
                    }
                };

                drawStructure(0, -10, 0, 70, 50, 60, true);  // Main House
                drawStructure(50, -20, 5, 35, 35, 45, true); // Side wing
                
                // Chimney
                for (let x = -25; x < -15; x += density) {
                    for (let z = -25; z < -15; z += density) {
                        for (let y = 10; y < 65; y += density) {
                            points.push([x, y, z]);
                        }
                    }
                }
                
                return points;
            }
            
            // Helper: Generate realistic semi-truck shape
            function generateTruckPoints() {
                const points = [];
                const density = 2.2;
                
                const drawPart = (xOff, yOff, zOff, w, h, d, options = {}) => {
                    for (let x = -w/2; x <= w/2; x += density) {
                        for (let y = -h/2; y <= h/2; y += density) {
                            for (let z = -d/2; z <= d/2; z += density) {
                                const isSurface = Math.abs(x - w/2) < 1 || Math.abs(x + w/2) < 1 || 
                                                 Math.abs(y - h/2) < 1 || Math.abs(y + h/2) < 1 || 
                                                 Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1;
                                if (isSurface) {
                                    // Window cutout logic
                                    if (options.isCab && x < -w/2 + 2 && Math.abs(z) < d/2 - 4 && y > 0) {
                                        if (Math.abs(z) > d/2 - 6 || y > h/2 - 3) points.push([x + xOff, y + yOff, z + zOff]);
                                        continue;
                                    }
                                    if (Math.random() > 0.1) points.push([x + xOff, y + yOff, z + zOff]);
                                }
                            }
                        }
                    }
                };

                // Cab
                drawPart(-45, -5, 0, 35, 50, 38, { isCab: true });
                // Mirrors
                [1, -1].forEach(side => {
                    for (let y = 0; y < 15; y += 3) points.push([-58, y, side * 22]);
                });
                // Exhausts
                for (let y = -10; y < 45; y += 4) {
                    points.push([-30, y, 16], [-30, y, -16]);
                }

                // Cargo Trailer
                drawPart(25, 5, 0, 100, 65, 42);
                
                // Chassis and Fuel Tanks
                for (let x = -60; x < 65; x += 5) {
                    points.push([x, -25, 12], [x, -25, -12]);
                    if (x > -35 && x < -15) {
                        for (let angle = 0; angle < Math.PI * 2; angle += 0.8) {
                            points.push([x, -22 + Math.cos(angle)*8, 22 + Math.sin(angle)*8]);
                            points.push([x, -22 + Math.cos(angle)*8, -22 - Math.sin(angle)*8]);
                        }
                    }
                }

                // 4 Wheels
                const wheelPos = [[-55, -30], [50, -30]];
                wheelPos.forEach(([wx, wy]) => {
                    for (let side = -1; side <= 1; side += 2) {
                        const zCenter = side * 24;
                        for (let dz = -5; dz <= 5; dz += 2.5) {
                            for (let angle = 0; angle < Math.PI * 2; angle += 0.4) {
                                const r = 13;
                                points.push([wx + Math.cos(angle) * r, wy + Math.sin(angle) * r, zCenter + dz]);
                            }
                        }
                    }
                });
                
                return points;
            }
            
            // Create Three.js scene for each canvas
            document.querySelectorAll('.card-3d-viz').forEach(canvas => {
                const shape = canvas.dataset.shape;
                const container = canvas.parentElement;

                const initViz = (w, h) => {
                    if (canvas.dataset.loaded === "true") return;
                    canvas.dataset.loaded = "true";
                    
                    try {
                        console.log(`Initializing ${shape} viz: ${w}x${h}`);
                        const scene = new THREE.Scene();
                        const camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 2000);
                        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
                        
                        renderer.setPixelRatio(window.devicePixelRatio || 1);
                        renderer.setSize(w, h);
                        camera.position.z = 250;

                        // Mapping shapes to GLB files
                        const glbMap = {
                            'phone': 'Phone.glb',
                            'building': 'Farm house.glb',
                            'truck': 'Truck.glb'
                        };

                        let object3D = null;
                        const glbFile = glbMap[shape];

                        if (glbFile) {
                            const loader = new GLTFLoader();
                            loader.load(glbFile, (gltf) => {
                                const model = gltf.scene || gltf.scenes[0];
                                
                                // 1. Normalize model scale BEFORE sampling to ensure grid consistency
                                const box = new THREE.Box3().setFromObject(model);
                                const size = new THREE.Vector3(); box.getSize(size);
                                const maxDim = Math.max(size.x, size.y, size.z);
                                const preScale = 160 / maxDim; // Reduced by 20% (was 200)
                                model.scale.setScalar(preScale);
                                model.updateMatrixWorld(true);
                                
                                // 2. Convert Mesh to Points with an "organized" grid feel
                                const pointsArr = [];
                                const gridSet = new Set();
                                const gridSize = shape === 'phone' ? 2.0 : 2.6; // Increased spacing (was 1.5/2.0)
                                
                                const meshes = [];
                                model.traverse(c => { if (c.isMesh && c.geometry) meshes.push(c); });
                                
                                // Calculate total surface area for proportional distribution
                                let totalArea = 0;
                                const meshData = meshes.map(m => {
                                    if(!m.geometry.boundingBox) m.geometry.computeBoundingBox();
                                    const s = new THREE.Vector3();
                                    m.geometry.boundingBox.getSize(s);
                                    const area = 2 * (s.x * s.y + s.x * s.z + s.y * s.z);
                                    totalArea += area;
                                    return { mesh: m, area: area };
                                });

                                meshData.forEach(data => {
                                    const sampler = new MeshSurfaceSampler(data.mesh).build();
                                    const tempPos = new THREE.Vector3();
                                    const samplesForThisMesh = (70000 * data.area) / totalArea; // Reduced pool (was 90000)

                                    for (let i = 0; i < samplesForThisMesh; i++) {
                                        sampler.sample(tempPos);
                                        tempPos.applyMatrix4(data.mesh.matrixWorld);
                                        
                                        const gx = Math.round(tempPos.x / gridSize) * gridSize;
                                        const gy = Math.round(tempPos.y / gridSize) * gridSize;
                                        const gz = Math.round(tempPos.z / gridSize) * gridSize;
                                        
                                        const key = `${gx.toFixed(1)}|${gy.toFixed(1)}|${gz.toFixed(1)}`;
                                        if (!gridSet.has(key)) {
                                            gridSet.add(key);
                                            pointsArr.push(gx, gy, gz);
                                        }
                                    }
                                });

                                const geo = new THREE.BufferGeometry();
                                geo.setAttribute('position', new THREE.Float32BufferAttribute(pointsArr, 3));
                                geo.center(); 

                                // Final normalization
                                const finalScale = shape === 'phone' ? 0.9 : 1.1; 
                                geo.scale(finalScale, finalScale, finalScale);

                                const canvasCircle = document.createElement('canvas');
                                canvasCircle.width = 64; canvasCircle.height = 64;
                                const ctxC = canvasCircle.getContext('2d');
                                ctxC.beginPath(); ctxC.arc(32, 32, 30, 0, Math.PI * 2);
                                ctxC.fillStyle = '#ffffff'; ctxC.fill();

                                const mat = new THREE.PointsMaterial({
                                    size: shape === 'phone' ? 1.8 : 2.1,
                                    map: new THREE.CanvasTexture(canvasCircle),
                                    color: 0x00ff88,
                                    transparent: true,
                                    opacity: 0.9,
                                    alphaTest: 0.05,
                                    depthWrite: false
                                });

                                const pts = new THREE.Points(geo, mat);
                                
                                // Adjust starting orientation
                                pts.rotation.y = shape === 'phone' ? Math.PI : Math.PI * -0.2;
                                
                                scene.add(pts);
                                object3D = pts;
                            }, undefined, (err) => {
                                console.error('GLTF load error', err);
                                // Fallback to procedural if GLB fails
                                loadFallback(shape, scene, (pts) => { object3D = pts; });
                            });

                            let rotX = 0.3, rotY = shape === 'phone' ? Math.PI : 0.5;
                            let targetRotX = rotX, targetRotY = rotY;

                            container.addEventListener('mousemove', (e) => {
                                const rect = container.getBoundingClientRect();
                                const mouseX = ((e.clientX - rect.left) / w - 0.5) * Math.PI;
                                const mouseY = ((e.clientY - rect.top) / h - 0.5) * Math.PI * 0.5;
                                targetRotY = (shape === 'phone' ? Math.PI : 0.5) + mouseX;
                                targetRotX = 0.3 + mouseY;
                            });

                            container.addEventListener('mouseleave', () => {
                                targetRotX = 0.3; targetRotY = shape === 'phone' ? Math.PI : 0.5;
                            });

                            function animateGLB() {
                                requestAnimationFrame(animateGLB);
                                if (object3D) {
                                    rotX += (targetRotX - rotX) * 0.05;
                                    rotY += (targetRotY - rotY) * 0.05;
                                    object3D.rotation.x = rotX;
                                    object3D.rotation.y = rotY;
                                    const s = 0.98 + Math.sin(Date.now() * 0.0008) * 0.02;
                                    object3D.scale.set(s, s, s);
                                }
                                renderer.render(scene, camera);
                            }
                            animateGLB();

                        }

                        // Helper for fallbacks to avoid code duplication
                        function loadFallback(shape, scene, callback) {
                            let pointsData;
                            switch(shape) {
                                case 'phone': pointsData = generatePhonePoints(); break;
                                case 'building': pointsData = generateBuildingPoints(); break;
                                case 'truck': pointsData = generateTruckPoints(); break;
                                default: pointsData = generatePhonePoints();
                            }
                            const geo = new THREE.BufferGeometry();
                            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pointsData.flat()), 3));
                            const canvasCircle = document.createElement('canvas');
                            canvasCircle.width = 64; canvasCircle.height = 64;
                            const ctxC = canvasCircle.getContext('2d');
                            ctxC.beginPath(); ctxC.arc(32, 32, 30, 0, Math.PI * 2);
                            ctxC.fillStyle = '#ffffff'; ctxC.fill();
                            const mat = new THREE.PointsMaterial({ size: 2.8, map: new THREE.CanvasTexture(canvasCircle), color: 0x00ff88, transparent: true, opacity: 0.9, alphaTest: 0.05, depthWrite: false });
                            const pts = new THREE.Points(geo, mat);
                            scene.add(pts);
                            callback(pts);
                        }

                        window.addEventListener('resize', () => {
                            const nw = container.clientWidth, nh = container.clientHeight;
                            if (nw > 0 && nh > 0) {
                                renderer.setSize(nw, nh);
                                camera.aspect = nw / nh;
                                camera.updateProjectionMatrix();
                            }
                        });
                    } catch (e) { console.error(e); }
                };

                const ro = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            initViz(width, height);
                            ro.disconnect();
                        }
                    }
                });
                ro.observe(container);
            });
        })();

        // Three.js Background - Positioned & Rounded
        function initBg() {
            const container = document.getElementById('bg-canvas');
            if(!container) return;
            
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x030303, 0.03);

            const getDims = () => ({
                w: container.clientWidth,
                h: container.clientHeight
            });
            let dims = getDims();

            const camera = new THREE.PerspectiveCamera(75, dims.w / dims.h, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
            renderer.setSize(dims.w, dims.h);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);

            // Geometry - Sharp Architectural Cubes (Edges only)
            const geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const edgesGeometry = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.85
            });
            
            const cubes = [];
            const group = new THREE.Group();
            
            // Cluster Logic: Rubik-style Grid (Organized but fractured)
            const gridSize = 4;
            const spacing = 1.4;
            for(let x=0; x<gridSize; x++) {
                for(let y=0; y<gridSize; y++) {
                    for(let z=0; z<gridSize; z++) {
                        // Skip some to create "voids" in the rubik structure
                        if(Math.random() < 0.4) continue;

                        const cube = new THREE.LineSegments(edgesGeometry, material.clone());
                        
                        // Base Grid Position
                        let px = (x - (gridSize-1)/2) * spacing;
                        let py = (y - (gridSize-1)/2) * spacing;
                        let pz = (z - (gridSize-1)/2) * spacing;

                        // "Fractured" logic: Spread some cubes away from the center
                        const distanceFactor = Math.random();
                        if(distanceFactor > 0.7) {
                            // Small outward nudge to keep them close but distinct
                            const dir = new THREE.Vector3(px, py, pz).normalize();
                            if(dir.length() === 0) dir.set(1, 1, 1).normalize();
                            
                            const pushDistance = 0.6 + Math.random() * 0.8; 
                            px += dir.x * pushDistance;
                            py += dir.y * pushDistance;
                            pz += dir.z * pushDistance;
                        }

                        cube.position.set(px, py, pz);
                        cube.rotation.set(0, 0, 0); // All cubes share the same orientation
                        group.add(cube);
                        cubes.push(cube);
                    }
                }
            }
            
            // Reposition beside text
            const updateGroupPos = () => {
                group.position.x = dims.w > 768 ? 4 : 0;
                group.position.y = dims.w > 768 ? 0 : -2;
            };
            updateGroupPos();
            scene.add(group);

            camera.position.z = 12;

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let selectedObject = null;
            let isDragging = false;
            const dragPlane = new THREE.Plane();
            const planeNormal = new THREE.Vector3(0, 0, 1);
            const intersection = new THREE.Vector3();
            let offset = new THREE.Vector3();

            const updateMouse = (e) => {
                const rect = container.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / dims.w) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / dims.h) * 2 + 1;
            };

            container.addEventListener('mousemove', (e) => {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);

                if (isDragging && selectedObject) {
                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        // Move in group space
                        const localIntersection = group.worldToLocal(intersection.clone().sub(offset));
                        selectedObject.position.copy(localIntersection);
                    }
                    return;
                }

                const intersects = raycaster.intersectObjects(cubes);
                document.body.style.cursor = intersects.length > 0 ? 'grab' : 'crosshair';
            });

            container.addEventListener('mousedown', (e) => {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubes);

                if (intersects.length > 0) {
                    isDragging = true;
                    selectedObject = intersects[0].object;
                    
                    planeNormal.copy(camera.position).normalize();
                    const worldPos = new THREE.Vector3();
                    selectedObject.getWorldPosition(worldPos);
                    dragPlane.setFromNormalAndCoplanarPoint(planeNormal, worldPos);
                    
                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        offset.copy(intersection).sub(worldPos);
                    }
                    
                    document.body.style.cursor = 'grabbing';
                    selectedObject.material.color.setHex(0xffffff); // Highlight white
                }
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                if(selectedObject) {
                    selectedObject.material.color.setHex(0x00ff88); // Reset to green
                    selectedObject = null;
                }
            });

            window.addEventListener('resize', () => {
                dims = getDims();
                camera.aspect = dims.w / dims.h;
                camera.updateProjectionMatrix();
                renderer.setSize(dims.w, dims.h);
                updateGroupPos();
            });

            function animate() {
                requestAnimationFrame(animate);
                // ALWAYS rotate to maintain momentum
                group.rotation.y += 0.003;
                group.rotation.z += 0.001;
                renderer.render(scene, camera);
            }
            animate();
        }
        
        initBg();
        
        // --- BG Particles & Parallax ---
        (function initParticles(){
            const container = document.getElementById('bg-canvas');
            if(!container) return;

            // canvas for particles
            const canvas = document.createElement('canvas');
            canvas.id = 'bg-particles';
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            let DPR = Math.max(1, window.devicePixelRatio || 1);
            let W = 0, H = 0;
            function resize() {
                W = canvas.width = Math.max(300, container.clientWidth) * DPR;
                H = canvas.height = Math.max(300, container.clientHeight) * DPR;
                canvas.style.width = (W / DPR) + 'px';
                canvas.style.height = (H / DPR) + 'px';
            }
            window.addEventListener('resize', resize);
            resize();

            const PCOUNT = 80;
            const particles = [];
            for(let i=0;i<PCOUNT;i++) particles.push({ x: Math.random()*W, y: Math.random()*H, r: (Math.random()*1.6+0.6)*DPR, vx: (Math.random()-0.5)*0.25, vy: (Math.random()-0.5)*0.25, a: (Math.random()*0.6+0.15) });

            let mx = 0, my = 0, tx = 0, ty = 0;
            container.addEventListener('mousemove', e => {
                const rect = container.getBoundingClientRect();
                mx = ((e.clientX - rect.left) / rect.width - 0.5);
                my = ((e.clientY - rect.top) / rect.height - 0.5);
            });
            window.addEventListener('scroll', () => {
                ty = window.scrollY * 0.01;
            });

            function draw() {
                ctx.clearRect(0,0,W,H);
                tx += (mx*30 - tx) * 0.06; // smooth
                ty += (ty - ty) * 0.02; // no-op but reserved for future

                for(let p of particles){
                    p.x += p.vx; p.y += p.vy;
                    if(p.x < -50) p.x = W + 50;
                    if(p.x > W + 50) p.x = -50;
                    if(p.y < -50) p.y = H + 50;
                    if(p.y > H + 50) p.y = -50;

                    ctx.beginPath();
                    ctx.fillStyle = `rgba(0,255,136,${p.a})`;
                    ctx.arc(p.x + mx*12*DPR, p.y + my*12*DPR, p.r, 0, Math.PI*2);
                    ctx.fill();
                }
                requestAnimationFrame(draw);
            }
            draw();

            // parallax transform for bg-canvas
            let px = 0, py = 0;
            function updateParallax(){
                px += (mx * 8 - px) * 0.06;
                py += (my * 8 - py) * 0.06;
                container.style.transform = `translate3d(${px}px, ${py}px, 0)`;
                requestAnimationFrame(updateParallax);
            }
            updateParallax();
        })();

        // Reveal, arrow micro-interactions, tilt & scroll parallax
        (function initRevealAndTilt(){
            // Intersection Observer for reveal animations
            const io = new IntersectionObserver((entries) => {
                entries.forEach((entry, idx) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                        const delay = (entry.target.datasetRevealIndex || 0) * 60;
                        entry.target.style.transitionDelay = (delay) + 'ms';
                        io.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.12 });

            const workCards = Array.from(document.querySelectorAll('.work-card, .section-heading'));
            workCards.forEach((el, i) => {
                el.datasetRevealIndex = i;
                el.classList.add('reveal');
                io.observe(el);
            });

        })();

        // --- INTERACTIVE NODE GRAPH (V4.5 FIXED) ---
        // Load the 3d-force-graph library dynamically
        function loadGraphLibrary() {
            return new Promise((resolve, reject) => {
                if (typeof ForceGraph3D !== 'undefined') {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/3d-force-graph@1.70.0';
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load 3d-force-graph'));
                document.head.appendChild(script);
            });
        }

        function initNodeGraph() {
            const elem = document.getElementById('node-graph-viz');
            if (!elem) {
                console.error('Graph container not found');
                return;
            }

            // Wait until element has dimensions
            if (elem.clientWidth === 0 || elem.clientHeight === 0) {
                console.log('Graph waiting for layout... Will retry.');
                setTimeout(initNodeGraph, 300);
                return;
            }

            console.log(`Graph container ready: ${elem.clientWidth}x${elem.clientHeight}`);

            if (typeof ForceGraph3D === 'undefined') {
                console.error('ForceGraph3D not available');
                elem.innerHTML = "<div class='graph-loading'>[GRAPH_LIB_ERROR] ForceGraph3D not loaded</div>";
                return;
            }

            // Create glow texture for nodes
            function createGlowTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            // Spread nodes evenly throughout 3D space like a star field
            // Using spherical distribution with randomization for natural look
            
            // Helper function to generate points on a sphere with variation
            function sphericalPoint(radius, indexRatio, variation = 30) {
                const phi = Math.acos(-1 + (2 * indexRatio));
                const theta = Math.sqrt((100) * Math.PI) * phi;
                
                const r = radius + (Math.random() - 0.5) * variation;
                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);
                
                return { x, y, z };
            }
            
            const allSkills = [
                // Research Methods
                { name: "Generative Research", type: "methods" },
                { name: "Evaluative Research", type: "methods" },
                { name: "Mixed Methods", type: "methods" },
                { name: "User Interviews", type: "methods" },
                { name: "Contextual Inquiry", type: "methods" },
                { name: "Usability Testing", type: "methods" },
                { name: "Card Sorting", type: "methods" },
                { name: "A/B Testing", type: "methods" },
                { name: "Analytics", type: "methods" },
                { name: "Heatmaps", type: "methods" },
                { name: "Personas", type: "artifacts" },
                { name: "JTBD", type: "artifacts" },
                { name: "Empathy Maps", type: "artifacts" },
                
                // Product Strategy
                { name: "Product Discovery", type: "decisions" },
                { name: "Value Proposition", type: "decisions" },
                { name: "OKRs", type: "decisions" },
                { name: "Roadmapping", type: "decisions" },
                { name: "North Star Metrics", type: "decisions" },
                { name: "Product Vision", type: "decisions" },
                { name: "Business Models", type: "decisions" },
                { name: "Competitive Analysis", type: "decisions" },
                { name: "Market Research", type: "decisions" },
                
                // Interaction Design
                { name: "Interaction Patterns", type: "artifacts" },
                { name: "Microinteractions", type: "artifacts" },
                { name: "Motion Design", type: "artifacts" },
                { name: "State Management", type: "artifacts" },
                { name: "Navigation Models", type: "artifacts" },
                { name: "Form Design", type: "artifacts" },
                
                // Information Architecture
                { name: "Site Maps", type: "artifacts" },
                { name: "Content Hierarchies", type: "artifacts" },
                { name: "Taxonomies", type: "artifacts" },
                { name: "Navigation Structures", type: "artifacts" },
                { name: "Wayfinding", type: "artifacts" },
                { name: "Search & Filtering", type: "artifacts" },
                
                // Usability & Accessibility
                { name: "Heuristics", type: "methods" },
                { name: "WCAG", type: "methods" },
                { name: "Inclusive Design", type: "methods" },
                { name: "Keyboard Navigation", type: "methods" },
                { name: "Screen Reader Support", type: "methods" },
                
                // Design Process
                { name: "Problem Framing", type: "methods" },
                { name: "Brainstorming", type: "methods" },
                { name: "Design Studios", type: "methods" },
                { name: "Prototype Testing", type: "methods" },
                { name: "Design Reviews", type: "methods" },
                { name: "Iterative Refinement", type: "methods" },
                
                // Design Systems
                { name: "Design Systems", type: "meta" },
                { name: "Component Libraries", type: "artifacts" },
                { name: "Pattern Libraries", type: "artifacts" },
                { name: "Design Tokens", type: "artifacts" },
                { name: "Governance Models", type: "meta" },
                
                // Metrics
                { name: "KPIs", type: "outcomes" },
                { name: "Activation", type: "outcomes" },
                { name: "Retention", type: "outcomes" },
                { name: "Conversion Rate", type: "outcomes" },
                { name: "Feature Adoption", type: "outcomes" },
                
                // Prototyping
                { name: "Wireframes", type: "artifacts" },
                { name: "Interactive Prototypes", type: "artifacts" },
                
                // Systems Thinking
                { name: "Feedback Loops", type: "meta" },
                { name: "Trade-offs", type: "meta" },
                { name: "Constraints", type: "meta" },
                { name: "Dependencies", type: "meta" },
                
                // Collaboration
                { name: "Product Management", type: "collab" },
                { name: "Engineering", type: "collab" },
                { name: "Workshop Facilitation", type: "collab" },
                { name: "Stakeholder Management", type: "collab" },
                
                // Ethics
                { name: "Privacy by Design", type: "ethics" },
                { name: "Consent", type: "ethics" },
                { name: "Dark Patterns Awareness", type: "ethics" },
                { name: "Bias Mitigation", type: "ethics" },
                
                // Additional Skills
                { name: "Design Critique", type: "collab" },
                { name: "Storytelling", type: "collab" },
                { name: "User Flows", type: "artifacts" },
                { name: "Journey Mapping", type: "artifacts" },
                { name: "Service Blueprints", type: "artifacts" },
                { name: "Tree Testing", type: "methods" },
                { name: "Guerilla Testing", type: "methods" },
                { name: "Cognitive Walkthrough", type: "methods" },
                { name: "Funnel Analysis", type: "methods" },
                { name: "Cohort Analysis", type: "methods" }
            ];
            
            // Generate nodes with spherical distribution
            const allNodes = allSkills.map((skill, index) => {
                const pos = sphericalPoint(120, index / allSkills.length, 30);
                return {
                    id: skill.name,
                    group: skill.type,
                    val: 10,
                    ...pos
                };
            });

            // Connect every node to its neighbors to form a cohesive web
            const links = [];
            allNodes.forEach((node, i) => {
                // Find 2-3 nearest neighbors based on spherical coordinates to create a mesh feel
                const neighbors = allNodes
                    .map((n, idx) => ({ id: n.id, dist: Math.hypot(n.x - node.x, n.y - node.y, n.z - node.z), idx }))
                    .filter(n => n.id !== node.id)
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, 2);
                
                neighbors.forEach(nb => {
                    // Avoid duplicate links
                    if (i < nb.idx) links.push({ source: node.id, target: nb.id });
                });
            });

            const data = {
                nodes: allNodes,
                links: links
            }; 

            try {
                // Clear loading indicator
                elem.innerHTML = '<div class="graph-loading">[RENDERING...]</div>';
                
                console.log('Initializing ForceGraph3D...');
                let isRotating = true;
                let hoveredNode = null;
                let currentHoverId = null; // For dynamic link highlighting
                const nodeObjects = new Map();
                
                // Create custom node object with label as text sprite
                const Graph = ForceGraph3D()(elem)
                    .graphData(data)
                    .backgroundColor('rgba(0, 0, 0, 0)')
                    .showNavInfo(false)
                    .linkWidth(0.6)
                    .linkColor(link => {
                        const s = (link.source && link.source.id) || link.source;
                        const t = (link.target && link.target.id) || link.target;
                        return (currentHoverId && (s === currentHoverId || t === currentHoverId))
                            ? 'rgba(0,255,136,0.8)'
                            : 'rgba(0,255,136,0.15)';
                    })
                    .linkOpacity(0.2)
                    .nodeLabel(null) // Disable default tooltips
                    .width(elem.clientWidth)
                    .height(elem.clientHeight)
                    .enableNodeDrag(false)
                    .cooldownTicks(0)
                    .nodeThreeObject(node => {
                        const group = new THREE.Group();

                        // 1. The Core Cube (now emits light)
                        const size = 2.0;
                        const geometry = new THREE.BoxGeometry(size, size, size);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x00ff88,
                            transparent: true,
                            opacity: 0.7
                        });
                        const cube = new THREE.Mesh(geometry, material);
                        group.add(cube);

                        // 2. The Text Label (Always facing camera)
                        // Using a canvas-based sprite for clean, sharp text
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        context.font = 'bold 24px monospace';
                        context.fillStyle = '#ffffff';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(node.id.toUpperCase(), 128, 32);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
                        const label = new THREE.Sprite(spriteMat);
                        label.position.set(0, 10, 0); // Position above node
                        label.scale.set(30, 7.5, 1);
                        group.add(label);

                        // 3. Selective Glow
                        const glowTex = createGlowTexture();
                        const glowMat = new THREE.SpriteMaterial({
                            map: glowTex,
                            color: 0x00ff88,
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending
                        });
                        const glow = new THREE.Sprite(glowMat);
                        glow.scale.set(size * 4, size * 4, 1);
                        group.add(glow);

                        group.userData = { cube, label, glow, originalOpacity: 0.7 };
                        nodeObjects.set(node.id, group);
                        return group;
                    })
                    .onNodeHover(node => {
                        // Reset all nodes
                        nodeObjects.forEach((obj, id) => {
                            obj.userData.cube.scale.set(1, 1, 1);
                            obj.userData.cube.material.opacity = 0.7;
                            obj.userData.label.scale.set(30, 7.5, 1);
                            obj.userData.label.material.opacity = 0.9;
                            obj.userData.glow.material.opacity = 0.3;
                        });

                        hoveredNode = node;
                        currentHoverId = node ? node.id : null; 
                        
                        // Stop rotation when hovering
                        isRotating = !!node ? false : true; 
                        elem.style.cursor = node ? 'pointer' : 'default';

                        // Highlight hovered node and refresh link colors
                        if (node) {
                            const group = nodeObjects.get(node.id);
                            if (group) {
                                group.userData.cube.scale.set(2, 2, 2);
                                group.userData.cube.material.opacity = 1.0;
                                group.userData.label.scale.set(40, 10, 1);
                                group.userData.label.material.opacity = 1.0;
                                group.userData.glow.material.opacity = 0.6;
                            }
                        }

                        // Trigger link color refresh
                        Graph.linkColor(Graph.linkColor());
                    });

                console.log('Graph created successfully');

                // Cinematic auto-rotation
                const distance = 320;
                let angle = 0;

                function rotateCamera() {
                    if (isRotating) {
                        angle += 0.0008; 
                        const camera = Graph.camera();
                        camera.position.x = distance * Math.sin(angle);
                        camera.position.z = distance * Math.cos(angle);
                        camera.position.y = 40 + Math.sin(angle * 0.5) * 15;
                        camera.lookAt(0, 0, 0);
                    }
                    requestAnimationFrame(rotateCamera);
                }
                
                Graph.controls().enabled = false;
                rotateCamera();

                // Force explicit dimensions
                setTimeout(() => {
                    Graph.width(elem.clientWidth);
                    Graph.height(elem.clientHeight);
                }, 100);

                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        if(width > 0 && height > 0) {
                            Graph.width(width);
                            Graph.height(height);
                        }
                    }
                });
                resizeObserver.observe(elem);

                // --- Node pulsing animation (radial breathing) ---
                const originalPos = new Map();
                data.nodes.forEach((n, idx) => {
                    originalPos.set(n.id, { x: n.x, y: n.y, z: n.z, offset: Math.random() * Math.PI * 2 });
                });

                (function animateNodes() {
                    const t = performance.now() / 1000;
                    data.nodes.forEach(n => {
                        const o = originalPos.get(n.id);
                        const k = 1 + Math.sin(t * 0.6 + o.offset) * 0.08; // +/-8%
                        n.x = o.x * k;
                        n.y = o.y * k;
                        n.z = o.z * k;
                    });
                    Graph.graphData(data);
                    requestAnimationFrame(animateNodes);
                })();
                
            } catch (e) {
                console.error('Graph initialization error:', e);
                elem.innerHTML = `<div class='graph-loading'>[GRAPH_ERROR] ${e.message}</div>`;
            }
        }
        
        // Load library and initialize graph
        loadGraphLibrary()
            .then(() => {
                console.log('3d-force-graph library loaded successfully');
                // Wait for DOM layout
                setTimeout(initNodeGraph, 500);
            })
            .catch(err => {
                console.error('Failed to load graph library:', err);
                const elem = document.getElementById('node-graph-viz');
                if (elem) {
                    elem.innerHTML = "<div class='graph-loading'>[LIBRARY_LOAD_FAILED] Check console</div>";
                }
            });
    </script>

    <!-- Background Animation Script -->
    <script type="module">
        import * as THREE from 'three';

        // Updated ID to avoid conflict with Hero Cubes
        const canvas = document.getElementById('bg-wave-canvas');
        const parent = canvas.parentElement;
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        
        function updateSize() {
            const w = parent.clientWidth;
            const h = parent.clientHeight;
            renderer.setSize(w, h);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            if (camera) {
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            }
        }

        const scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x050505, 0.0015); 

        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.z = 50; 
        camera.position.y = 15;
        camera.rotation.x = -0.3;

        updateSize();

        const geometry = new THREE.BufferGeometry();
        // Waves
        const count = 2500;
        const positions = new Float32Array(count * 3);
        const originalPositions = new Float32Array(count * 3);
        
        // Spread particles in a grid/plane
        let i = 0;
        const size2 = 180;
        const gap = 3.5;
        const columns = Math.sqrt(count);
        
        for (let x = 0; x < columns; x++) {
            for (let z = 0; z < columns; z++) {
                // Centered grid
                const px = (x * gap) - (columns * gap) / 2;
                const pz = (z * gap) - (columns * gap) / 2;
                
                positions[i] = px;
                positions[i+1] = 0; // Y
                positions[i+2] = pz;
                
                originalPositions[i] = px;
                originalPositions[i+1] = 0;
                originalPositions[i+2] = pz;

                i += 3;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            size: 0.15,
            color: 0x00ff88, // Accent color
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            const time = clock.getElapsedTime() * 0.5;

            // Wave effect
            const pos = geometry.attributes.position.array;
            for(let j=0; j < count; j++) {
                const x = originalPositions[j*3];
                const z = originalPositions[j*3 + 2];
                // Sine wave based on x, z and time
                pos[j*3 + 1] = (Math.sin(x * 0.05 + time) * 3) + (Math.cos(z * 0.05 + time) * 3); 
            }
            geometry.attributes.position.needsUpdate = true;

            // Gentle rotation
            particles.rotation.y = time * 0.02;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- Icosahedron Button Logic ---
        const icoButtons = document.querySelectorAll('.ico-btn');
        const icoScenes = [];

        icoButtons.forEach(btn => {
            const canvas = btn.querySelector('.ico-canvas');
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(100, 100);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            camera.position.z = 6; // Moved back for more room

            // Wireframe Icosahedron
            const geometry = new THREE.IcosahedronGeometry(1.5, 1); // Reduced size
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.4 
            });
            const mesh = new THREE.LineSegments(edges, material);
            scene.add(mesh);

            // Inner solid but very faint icosahedron for volume
            const innerGeo = new THREE.IcosahedronGeometry(1.45, 0); // Reduced size
            const innerMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.05
            });
            const innerMesh = new THREE.Mesh(innerGeo, innerMat);
            scene.add(innerMesh);

            icoScenes.push({ btn, scene, camera, renderer, mesh, innerMesh });
        });

        function animateIcos() {
            icoScenes.forEach(item => {
                const isHovered = item.btn.matches(':hover');
                const speed = isHovered ? 0.02 : 0.005;
                
                item.mesh.rotation.y += speed;
                item.mesh.rotation.z += speed * 0.5;
                item.innerMesh.rotation.y += speed;
                item.innerMesh.rotation.z += speed * 0.5;

                // Scale effect on hover
                const targetScale = isHovered ? 1.2 : 1.0;
                item.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                item.innerMesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                
                // Opacity effect
                item.mesh.material.opacity = THREE.MathUtils.lerp(item.mesh.material.opacity, isHovered ? 0.8 : 0.4, 0.1);

                item.renderer.render(item.scene, item.camera);
            });
            requestAnimationFrame(animateIcos);
        }
        animateIcos();

        // Resize
        window.addEventListener('resize', updateSize);
    </script>
</body>
</html>
