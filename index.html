<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIYANO // PRODUCT_DESIGN</title>
    <meta name="description" content="Product Design com foco em impacto: casos Algar Telecom e Volpi com métricas, pesquisa e execução." />
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
        "three/": "https://unpkg.com/three@0.128.0/"
      }
    }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050505;
            --surface: #0f0f0f;
            --accent: #00ff88; /* Bright Green */
            --accent-glow: rgba(0, 255, 136, 0.3);
            --text-main: #ffffff;
            --text-dim: #888;
            --border: #222;
            --font-main: 'Inter', sans-serif;
        }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: var(--font-main);
            overflow-x: hidden;
            line-height: 1.5;
            position: relative;
        }

        /* Ambient Lighting Effects */


        .bg-noise {
            position: fixed;
            inset: 0;
            z-index: 5;
            opacity: 0.05;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3BaseFilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
        }

        /* Ensure content sits above background layers */
        main {
            position: relative;
            z-index: 10;
        }

        @keyframes kineticDrift {
            0% { background-position: 0 0; }
            100% { background-position: 60px 60px; }
        }

        .mono { font-family: 'JetBrains Mono', monospace; }

        /* Floating Nav - Optimized */
        .hud-nav {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(0);
            z-index: 1000;
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 1;
            animation: navFloat 6s ease-in-out infinite;
        }

        @keyframes navFloat {
            0%, 100% { transform: translateX(-50%) translateY(0px); }
            50% { transform: translateX(-50%) translateY(-3px); }
        }

        .hud-nav.nav-hidden {
            /* Restoring previous hide animation: translate out of view vertically.
               Logo is now separated from the HUD so this transform won't affect it. */
            opacity: 0;
            transform: translateX(-50%) translateY(-40px);
            pointer-events: none;
            will-change: transform, opacity;
        }

        .hud-nav:hover {
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
        }
        
        .logo-box {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            border-right: 1px solid var(--border);
        }
        .logo-canvas {
            width: 36px;
            height: 36px;
            display: block;
        }
        .site-logo {
            position: fixed;
            top: 20px;
            left: 40px; /* default left: aligned to grid; JS will refine */
            z-index: 1002;
            display: flex;
            align-items: center;
            gap: 2px; /* tightened spacing */
            padding: 2px 4px;
            background: transparent;
            border: none;
            border-radius: 0;
            box-shadow: none;
            /* remove transitions to prevent movement during scroll */
            transition: none;
            cursor: pointer;
        }
        .site-logo:hover { transform: translateY(-2px); }
        .logo-text {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.12em;
            color: var(--text-main);
            text-transform: uppercase;
        }
        @media (max-width: 640px) {
            .site-logo { left: 16px; padding: 4px; }
        }
        .nav-indicator {
            position: absolute;
            bottom: -6px;
            left: 50%;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(0,255,136,0.6), rgba(0,255,136,0.2));
            border-radius: 2px;
            transition: left 0.25s ease, width 0.25s ease;
            pointer-events: none;
            z-index: 1001;
        }
        .hud-link {
            font-family: 'JetBrains Mono';
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-dim);
            padding: 8px 12px;
            text-decoration: none;
            transition: color 0.2s, transform 0.18s;
            opacity: 0;
            transform: translateY(6px);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .hud-icon {
            width: 14px;
            height: 14px;
            display: inline-flex;
            color: var(--text-dim);
            transition: color 0.18s, transform 0.18s;
        }
        .hud-link:hover .hud-icon, .hud-link:focus .hud-icon {
            color: var(--accent);
            transform: translateY(-1px) scale(1.05);
        }
        .hud-link .hud-label { display:inline-block; }

        .nav-links {
            display: flex;
            padding: 0 8px;
        }

        .hud-link {
            font-family: 'JetBrains Mono';
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            padding: 8px 16px;
            text-decoration: none;
            transition: color 0.2s;
        }
        .hud-link:hover { 
            color: var(--accent);
            text-shadow: 0 0 8px var(--accent-glow);
        }

        /* Grid Layout */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 40px;
        }

        /* Hero */
        .hero-section {
            height: 100vh;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 10;
            overflow: hidden;
        }

        .bg-hero-container {
            position: absolute;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background: #000;
        }

        #bg-wave-canvas, #bg-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #bg-wave-canvas {
            opacity: 0.6;
            z-index: 0;
        }

        #bg-canvas {
            z-index: 1;
            pointer-events: auto; /* Allow dragging cubes */
        }

        .bg-vignette {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, transparent 0%, var(--bg) 95%);
            z-index: 2;
            pointer-events: none;
        }
        .hero-title {
            font-family: 'JetBrains Mono';
            font-size: 6vw;
            line-height: 0.9;
            letter-spacing: -0.05em;
            text-transform: uppercase;
            font-weight: 800;
            /* smooth transform for hero transitions */
            transition: opacity 320ms ease, transform 420ms cubic-bezier(0.2, 0.9, 0.28, 1);
            will-change: opacity, transform;
        }
        .badge {
            display: inline-block;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--text-dim);
            letter-spacing: 0.12em;
            margin-bottom: 18px;
            font-family: 'JetBrains Mono';
            background: linear-gradient(90deg, rgba(0,255,136,0.06), rgba(0,255,136,0.02));
            border-left: 3px solid var(--accent);
            border-radius: 6px;
            padding-left: 10px;
            text-transform: uppercase;
            font-weight: 600;
            transition: opacity 220ms ease, transform 320ms cubic-bezier(0.2, 0.9, 0.28, 1);
        }

        .badge:hover {
            color: var(--text-main);
            background: linear-gradient(90deg, rgba(0,255,136,0.09), rgba(0,255,136,0.04));
        }

        /* Animation helper classes for hero A/B demo */
        .hero-fade-out {
            opacity: 0; transform: translateY(-8px) scale(0.995);
        }
        .hero-fade-in {
            opacity: 1; transform: translateY(0px) scale(1);
        }

        /* 3D flip title animation (Traf-inspired) */
        .title-clip { display:inline-block; overflow:hidden; vertical-align:middle; perspective: 800px; -webkit-perspective: 800px; }
        .title-word { display:inline-flex; white-space: nowrap; margin-right: 0.35ch; align-items: center; }
        .title-space { display:inline-block; width: 0.35ch; }
        .title-letter { display:inline-block; transition: transform 520ms cubic-bezier(0.2,0.9,0.28,1), opacity 360ms ease, text-shadow 420ms ease; transform-origin: 50% 60%; transform-style: preserve-3d; backface-visibility: hidden; will-change: transform, opacity; vertical-align: middle; overflow: hidden; }
        .title-letter.letter-enter { transform: rotateX(80deg) translateY(18px) translateZ(6px) scale(0.985); opacity: 0; }
        .title-letter.letter-exit { transform: rotateX(-30deg) translateY(-20px) translateZ(-2px) scale(0.98); opacity: 0; }
        .title-letter.glow { text-shadow: 0 0 10px rgba(255,0,255,0.25), 0 0 10px rgba(0,255,255,0.25); }
        /* Refined Terminal Decode Effect */
        .title-letter.decoding { color: transparent; opacity: 0; transition: none; font-family: 'JetBrains Mono', monospace; position: relative; }
        .title-letter.decoding.active { color: #fff; opacity: 1; text-shadow: -1.5px 0 0 #ff00ff, 1.5px 0 0 #00ffff, 0 0 6px rgba(255,255,255,0.8); }
        /* The glitchy terminal block cursor */
        .title-letter.has-cursor::after { 
            content: ''; 
            position: absolute; 
            inset: 0; 
            background: #fff; 
            box-shadow: -2px 0 0 #ff00ff, 2px 0 0 #00ffff; 
            z-index: 1; 
            animation: blinkGlitch 80ms infinite;
        }
        .title-letter.settled { transform: none; text-shadow: none; opacity: 1; color: inherit; transition: color 200ms ease; }
        @keyframes blinkGlitch { 
            0%, 100% { opacity: 1; transform: translateX(0); } 
            50% { opacity: 0.8; transform: translateX(1px); } 
        }
        
        @media (max-width: 640px) {
            .title-word { margin-right: 0.25ch; }
            .title-space { width: 0.25ch; }
        }
        @media (prefers-reduced-motion: reduce) {
            .title-letter { transition: none !important; }
            .title-letter.letter-enter, .title-letter.letter-exit { transform: none !important; opacity: 1 !important; }
        }

        /* Dev title controls removed (production) */

        /* Glitch effect layers */
        .title-glitch { position: relative; display:inline-block; }
        .title-glitch .glitch-layer { position:absolute; top:0; left:0; right:0; bottom:0; pointer-events:none; mix-blend-mode: screen; opacity:0; }
        .glitch-layer.layer-r { color: rgba(255,0,0,0.85); transform: translateX(-6px) translateY(0); }
        .glitch-layer.layer-g { color: rgba(0,255,136,0.85); transform: translateX(6px) translateY(0); }
        .glitch-animate .glitch-layer { animation: glitch-anim 420ms cubic-bezier(0.2,0.9,0.28,1) forwards; }
        @keyframes glitch-anim { 0% { opacity:1; transform: translateX(6px) skewX(-6deg) scale(1.02); } 60% { opacity:0.7; transform: translateX(-4px) skewX(3deg) scale(1.0); } 100% { opacity:0; transform: translateX(0) scale(1); } }

        /* CRT style */
        .title-crt { color:#b3ffb3; font-family: 'Courier Prime', monospace; letter-spacing:0.02em; text-shadow: 0 0 2px rgba(0,255,136,0.15); }
        .crt-scanline { position:absolute; inset:0; background-image: linear-gradient(transparent 50%, rgba(0,0,0,0.06) 51%); background-size:100% 4px; pointer-events:none; mix-blend-mode: overlay; opacity:0.22; }

        /* Particle canvas overlay */
        .particle-layer { position:absolute; left:0; top:0; pointer-events:none; z-index:9999; }
        .title-indicator { margin-top:8px; }
        .title-hint { font-size:12px; color:var(--text-dim); margin-left:8px; }
        

        /* Works Grid - Bento Box Layout */
        .work-bento {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 20px;
            margin-bottom: 80px;
        }

        .work-card {
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.4) 0%, rgba(10, 10, 10, 0.3) 100%);
            backdrop-filter: blur(40px) saturate(140%);
            border: 2px solid;
            border-color: rgba(255, 255, 255, 0.15);
            transition: all 0.5s cubic-bezier(0.2, 0.9, 0.3, 1);
            min-height: 420px;
            display: flex;
            flex-direction: column;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 2px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
        }

        .work-card.featured {
            grid-column: span 12;
            min-height: 520px;
        }

        .work-card.medium {
            grid-column: span 6;
            min-height: 460px;
        }

        /* Ensure all cards have identical glass properties */
        .work-card.featured,
        .work-card.medium {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.4) 0%, rgba(10, 10, 10, 0.3) 100%);
            backdrop-filter: blur(40px) saturate(140%);
            border: 2px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 2px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
        }

        .card-link {
            display: flex;
            flex-direction: column;
            height: 100%;
            text-decoration: none;
            color: inherit;
            position: relative;
            z-index: 1;
            padding: 40px;
        }

        .card-bg {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            transition: transform 0.6s cubic-bezier(0.2, 0.9, 0.3, 1), filter 0.4s ease, opacity 0.4s ease;
            filter: brightness(0.5) saturate(0.7);
            opacity: 0.5;
            z-index: 0;
        }

        .work-card:hover .card-bg {
            transform: scale(1.05);
            filter: brightness(0.6) saturate(0.9);
            opacity: 0.6;
        }

        .card-index {
            font-family: 'JetBrains Mono', monospace;
            font-size: 120px;
            font-weight: 900;
            line-height: 1;
            color: rgba(0,255,136,0.08);
            position: absolute;
            top: 20px;
            right: 30px;
            z-index: 1;
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .work-card:hover .card-index {
            color: rgba(0,255,136,0.14);
            transform: translateY(-8px);
        }

        .card-content {
            position: relative;
            z-index: 2;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card-meta {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent);
            font-weight: 600;
        }

        .card-title {
            font-size: 2.8rem;
            font-weight: 900;
            line-height: 0.95;
            letter-spacing: -0.03em;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .work-card.medium .card-title {
            font-size: 2.2rem;
        }

        .card-excerpt {
            font-size: 1rem;
            line-height: 1.6;
            color: #d4d4d4;
            max-width: 600px;
            margin-bottom: 24px;
        }

        .work-card.medium .card-excerpt {
            font-size: 0.92rem;
        }

        .card-metrics {
            display: flex;
            gap: 32px;
            margin-top: auto;
            padding-top: 24px;
        }

        .card-metrics.compact {
            gap: 24px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent);
            line-height: 1;
        }

        .work-card.medium .metric-value {
            font-size: 1.4rem;
        }

        .metric-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
        }

        .card-cta {
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--accent);
            font-weight: 600;
        }

        .card-3d-viz {
            display: block !important;
            opacity: 0.8;
        }

        .cta-arrow {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .work-card:hover .cta-arrow {
            transform: translateX(8px);
        }

        .work-card:hover {
            border-color: rgba(0, 255, 136, 0.5);
            transform: translateY(-10px) scale(1.01);
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.5) 0%, rgba(20, 20, 20, 0.4) 100%);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.9),
                0 8px 32px rgba(0, 255, 136, 0.2),
                0 0 80px rgba(0, 255, 136, 0.1),
                inset 0 2px 2px rgba(255, 255, 255, 0.5),
                inset 0 -3px 6px rgba(0, 0, 0, 0.7);
        }

        .card-3d-viz {
            position: absolute;
            inset: 0;
            z-index: 5;
            pointer-events: none;
            display: block !important;
            opacity: 1;
        }

        @media (max-width: 768px) {
            .work-card.featured,
            .work-card.medium {
                grid-column: span 12;
                min-height: 380px;
            }
            .card-link { padding: 28px; }
            .card-title { font-size: 2rem; }
            .card-index { font-size: 80px; top: 10px; right: 20px; }
        }

        /* Particles canvas overlay */
        #bg-particles {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* Reveal on scroll */
        .reveal { opacity: 0; transform: translateY(14px) scale(0.996); transition: opacity 0.6s ease, transform 0.6s cubic-bezier(.2,.9,.3,1); }
        .reveal.visible { opacity: 1; transform: translateY(0) scale(1); }

        /* Section headings */
        .section-heading { position: relative; }

        /* Node Graph */
        #node-graph-viz {
            width: 100%;
            height: 800px;
            background: transparent;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .graph-loading {
            font-family: 'JetBrains Mono';
            font-size: 12px;
            color: var(--accent);
            letter-spacing: 0.1em;
        }

        #bg-canvas {
            position: absolute;
            top: 0; right: 0; width: 100%; height: 100%;
            z-index: 0;
        }

        footer {
            padding: 160px 40px; /* Even more space for the wave */
            background: #050505;
            position: relative;
        }

        footer .grid-container { display: flex; align-items: center; justify-content: center; }
        footer .contact-inner { text-align: center; max-width: 900px; margin: 0 auto; }
        
        .contact-content-wrapper {
            padding: 80px 0;
            margin: 40px 0;
        }

        .contact-content h2 {
            font-family: 'JetBrains Mono', monospace;
            line-height: 0.9;
        }

        .contact-card:hover {
            border-color: rgba(0, 255, 136, 0.5);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.9),
                0 8px 32px rgba(0, 255, 136, 0.2),
                0 0 80px rgba(0, 255, 136, 0.1),
                inset 0 2px 2px rgba(255, 255, 255, 0.5),
                inset 0 -3px 6px rgba(0, 0, 0, 0.7);
            transform: translateY(-8px);
        }

        .contact-content h2 {
            font-size: 3.5rem;
            font-weight: 900;
            line-height: 1;
            letter-spacing: -0.02em;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #ffffff 0%, #888888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .contact-content p {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #d4d4d4;
            margin: 20px 0;
        }

        .contact-cta-row { display:flex; gap:20px; align-items:center; justify-content:center; margin-top:40px; flex-wrap: wrap; }

        .btn-primary {
            padding: 16px 32px;
            background: linear-gradient(90deg, #00ff88, #00d18f);
            color: #012;
            font-weight: 700;
            font-size: 1rem;
            box-shadow: 0 8px 30px var(--accent-glow);
            border: none;
            transition: all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1);
            text-decoration: none;
            display:inline-flex;
            align-items:center;
            gap:10px;
            cursor: pointer;
        }
        .btn-primary:hover { 
            transform: translateY(-6px) scale(1.05);
            box-shadow: 0 16px 50px var(--accent-glow);
            opacity:0.95; 
        }

        .contact-btn { 
            display: inline-flex; 
            align-items:center; 
            justify-content:center; 
            width:100px; 
            height:100px; 
            background: transparent;
            border: none;
            transition: all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1); 
            color: var(--accent);
            position: relative;
        }
        .ico-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .contact-btn svg { 
            position: relative;
            z-index: 1;
            width:22px; 
            height:22px; 
            fill:currentColor; 
            transition: transform 0.4s ease;
        }
        .contact-btn:hover svg { 
            transform: scale(1.2) rotate(5deg);
        }

        @media (max-width: 768px) {
            .hero-title { font-size: 3rem; }
            .contact-card { padding: 40px 24px; }
            .contact-content h2 { font-size: 2.5rem; }
            .contact-cta-row { gap: 12px; }
        }
    </style>
</head>
<body>
    <div class="bg-noise"></div>

    <div class="site-logo" role="link" aria-label="Home">
        <canvas class="logo-canvas" width="36" height="36" aria-hidden="true"></canvas>
        <span class="logo-text mono">MIYANO</span>
    </div>

    <nav class="hud-nav" role="navigation" aria-label="Main menu">
        <div class="nav-links">
            <a href="#" class="hud-link"><span class="hud-icon" aria-hidden="true"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 2v2"/></svg></span><span class="hud-label">About</span></a>
            <a href="#work" class="hud-link"><span class="hud-icon" aria-hidden="true"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="7" width="18" height="13" rx="2"/><path d="M16 3h-8v4h8z"/></svg></span><span class="hud-label">Work</span></a>
            <a href="#contact" class="hud-link"><span class="hud-icon" aria-hidden="true"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16v16H4z"/><path d="M4 8l8 6 8-6"/></svg></span><span class="hud-label">Contact</span></a>
        </div>
    </nav>

    <main class="relative z-10">
        <!-- Hero -->
        <section class="hero-section">
            <div class="bg-hero-container">
                <div id="bg-canvas"></div>
                <div class="bg-vignette"></div>
            </div>
            <div class="grid-container w-full relative z-10 pointer-events-none">
                <div class="col-span-12 md:col-span-8 pointer-events-auto">
                    <div id="hero-copy" class="hero-copy">
                        <div class="badge mono" id="hero-badge" aria-hidden="true" style="display:none;"></div>
                        <h1 class="hero-title" id="hero-title">I make products easier to use and faster to grow.</h1>
                        <p class="mt-6 text-neutral-200 max-w-lg text-lg leading-relaxed font-light" id="hero-sub">Product strategy • UX research • Interaction design • Cross-functional leadership</p>
                        <p class="mt-4 text-neutral-500 max-w-md text-sm italic" id="hero-micro">Open to senior product & design roles.</p>
                        <div class="mt-8">
                            <a id="hero-cta" href="#work" class="inline-block bg-white text-black px-6 py-3 font-bold text-sm uppercase tracking-wide hover:bg-neutral-200 transition-colors">SEE WORK ↓</a>
                        </div>

                    </div>
                </div>
            </div>
        </section>

        <!-- Projects -->
        <section id="work" class="py-32 relative overflow-hidden">
            <div class="max-w-[1400px] mx-auto px-8">
                <div class="mb-24 text-center">
                    <h2 class="mono text-xs text-neutral-500 tracking-[0.2em] uppercase mb-4">SELECTED WORK</h2>
                    <p class="text-neutral-400 text-sm max-w-md mx-auto">Three systems. Real impact. No BS.</p>
                </div>

                <!-- Bento Grid -->
                <div class="work-bento">
                    <!-- Featured: Algar (Large) -->
                    <article class="work-card featured" data-index="01">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(5,5,5,0.8)), url('assets/algar/thumb.svg'); background-position: center 25%; background-size: cover; z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="phone" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/algar.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">01</div>
                            <div class="card-content">
                                <span class="card-meta">Telecom / UX Performance</span>
                                <h3 class="card-title">ALGAR TELECOM</h3>
                                <p class="card-excerpt">Took a 1.9-star app to 3.0 by fixing what actually mattered: Login & Payments. No fluff.</p>
                                <div class="card-metrics">
                                    <div class="metric">
                                        <span class="metric-value">1.9 → 3.0</span>
                                        <span class="metric-label">App Rating</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">-42%</span>
                                        <span class="metric-label">Support Tickets</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Volpi (Medium) -->
                    <article class="work-card medium" data-index="02">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(15,5,25,0.92), rgba(5,5,5,0.88)), url('assets/volpi/thumb.svg'); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="building" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/volpi.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">02</div>
                            <div class="card-content">
                                <span class="card-meta">Fintech / Strategy</span>
                                <h3 class="card-title">VOLPI</h3>
                                <p class="card-excerpt">Turned home financing from a black box into a transparent checklist.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">-40%</span>
                                        <span class="metric-label">Process Time</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">+35%</span>
                                        <span class="metric-label">Conversion</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Torre (Medium) -->
                    <article class="work-card medium" data-index="03">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(20,10,5,0.92), rgba(5,5,5,0.88)), url('assets/torre/flow-1.svg'); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="truck" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/torre-controle.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">03</div>
                            <div class="card-content">
                                <span class="card-meta">Logistics / B2B</span>
                                <h3 class="card-title">TORRE DE CONTROLE</h3>
                                <p class="card-excerpt">Command center that routes 10k+ shipments. Real-time visibility meets workflow automation.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">-30%</span>
                                        <span class="metric-label">MTTR</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">50%</span>
                                        <span class="metric-label">Auto-routed</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>
                </div>
            </div>
        </section>



        <!-- Systems Thinking -->
        <section class="py-32">
            <div class="grid-container">
                <div class="col-span-12 text-center mb-16">
                    <h2 class="mono text-xs text-neutral-500 tracking-[0.2em] uppercase mb-8 section-heading reveal">SYSTEMS THINKING</h2>
                    <blockquote class="text-xl md:text-2xl text-neutral-200 font-light max-w-3xl mx-auto leading-relaxed">
                        "THE SYSTEM IS MORE THAN THE SUM OF ITS PARTS. <br>
                        <span class="text-neutral-500">IT IS THE PRODUCT OF THEIR INTERACTIONS."</span>
                    </blockquote>
                </div>
                <div class="col-span-12">
                    <div id="node-graph-viz">
                        <div class="graph-loading">[INITIALIZING_GRAPH...]</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Contact/Footer -->
        <footer id="contact" class="relative overflow-hidden">
            <div class="bg-hero-container">
                <canvas id="bg-wave-canvas"></canvas>
                <div class="bg-vignette"></div>
            </div>
            <div class="grid-container relative z-10">
                <div class="col-span-12 contact-inner">
                    <div class="contact-content-wrapper">
                        <div class="contact-content">
                            <h2 class="text-5xl md:text-7xl font-bold tracking-tighter mb-8">LET'S CREATE<br>SOMETHING GREAT</h2>
                            <p class="text-xl text-neutral-300 max-w-2xl mx-auto mb-4">Got an idea? A project? Or just want to chat about design and technology?</p>
                            <p class="mono text-accent text-sm tracking-widest uppercase">I'm always up for a conversation.</p>
                        </div>

                        <div class="contact-cta-row mt-12">
                            <a href="https://www.linkedin.com/" class="contact-btn ico-btn" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer" title="LINKEDIN">
                                <canvas class="ico-canvas"></canvas>
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4.98 3.5C4.98 4.88 3.86 6 2.5 6S0 4.88 0 3.5 1.12 1 2.5 1 4.98 2.12 4.98 3.5zM0 8.99h5V24H0V8.99zM8.5 8.99h4.78v2.07h.07c.67-1.27 2.3-2.61 4.74-2.61 5.07 0 6 3.34 6 7.68V24h-5v-7.52c0-1.79-.03-4.09-2.49-4.09-2.49 0-2.87 1.94-2.87 3.96V24h-5V8.99z"/></svg>
                            </a>
                            <a href="mailto:hello@miyano.net" class="contact-btn ico-btn" aria-label="Email">
                                <canvas class="ico-canvas"></canvas>
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z" fill="currentColor"/></svg>
                            </a>
                        </div>
                    </div>

                    <div style="margin-top: 60px; padding-top: 40px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                        <p class="mono text-[10px] text-neutral-600 mb-2">© 2026 Miyano Bot.</p>
                        <p class="mono text-xs opacity-40">No rights reserved. Copy this if you want.</p>
                    </div>
                </div>
            </div>
        </footer>
    </main>

    <script>
        // Dynamic Nav - Show/Hide on scroll
        const nav = document.querySelector('.hud-nav');
        let lastScrollY = window.scrollY;
        let ticking = false;

        function updateNav() {
            const currentScrollY = window.scrollY;
            const scrollingDown = currentScrollY > lastScrollY;
            const scrollingUp = currentScrollY < lastScrollY;
            const wasHidden = nav.classList.contains('nav-hidden');

            // Hide when scrolling down, show when scrolling up
            if (scrollingDown && currentScrollY > 100) {
                nav.classList.add('nav-hidden');
            } else if (scrollingUp) {
                nav.classList.remove('nav-hidden');
            }

            // Always show at very top
            if (currentScrollY < 50) {
                nav.classList.remove('nav-hidden');
            }

            const isHidden = nav.classList.contains('nav-hidden');
            if (wasHidden !== isHidden) {
                // notify other scripts (logo alignment) that nav changed
                window.dispatchEvent(new Event('nav-change'));
            }

            lastScrollY = currentScrollY;
            ticking = false;
        }

        window.addEventListener('scroll', () => {
            if (!ticking) {
                window.requestAnimationFrame(updateNav);
                ticking = true;
            }
        }, { passive: true });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'https://unpkg.com/three@0.128.0/examples/jsm/geometries/RoundedBoxGeometry.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
        import { MeshSurfaceSampler } from 'https://unpkg.com/three@0.128.0/examples/jsm/math/MeshSurfaceSampler.js';

        // Audio Engine (keeping in module scope or attaching to window)
        window.AUDIO = {
            ctx: null,
            init() { 
                if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            },
            play(freq) {
                this.init();
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.frequency.value = freq;
                o.type = 'sine';
                g.gain.setValueAtTime(0.02, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                o.connect(g);
                g.connect(this.ctx.destination);
                o.start();
                o.stop(this.ctx.currentTime + 0.1);
            }
        };

        // UI Interactions
        document.querySelectorAll('a, .work-card').forEach(el => {
            el.addEventListener('mouseenter', () => window.AUDIO.play(2000));
        });

        // 3D Particle Visualizations on Work Cards
        (function init3DViz() {
            console.log('Initializing 3D visualizations...');
            // Global sampling probability: lower = fewer dots (0..1)
            const SAMPLE_RATE = 0.25;

            // Stratified per-cell sampler to avoid holes while keeping low density
            function stratifiedSample(candidates, cellSize, sampleRate, minPerCell = 1, maxTotal = 10000) {
                const cells = new Map();
                for (const p of candidates) {
                    const cx = Math.floor(p[0] / cellSize);
                    const cy = Math.floor(p[1] / cellSize);
                    const cz = Math.floor(p[2] / cellSize);
                    const key = `${cx}|${cy}|${cz}`;
                    if (!cells.has(key)) cells.set(key, []);
                    cells.get(key).push(p);
                }
                const result = [];
                for (const pts of cells.values()) {
                    const k = Math.max(minPerCell, Math.round(sampleRate * pts.length));
                    // shuffle and take up to k
                    for (let i = pts.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [pts[i], pts[j]] = [pts[j], pts[i]];
                    }
                    const take = Math.min(k, pts.length);
                    for (let i = 0; i < take; i++) result.push(pts[i]);
                    if (result.length >= maxTotal) break;
                }
                // If still too many, sample down uniformly
                if (result.length > maxTotal) {
                    for (let i = result.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [result[i], result[j]] = [result[j], result[i]];
                    }
                    return result.slice(0, maxTotal);
                }
                return result;
            }
            
            // Helper: Generate phone shape as 3D points
            function generatePhonePoints() {
                const candidates = [];
                const w = 70, h = 140, d = 10, r = 12;
                // Aggressive low spacing for testing
                const density = 1.0;
                
                // Front and Back faces with rounded corners
                for (let x = -w/2; x <= w/2; x += density) {
                    for (let y = -h/2; y <= h/2; y += density) {
                        const dx = Math.abs(x) - (w/2 - r);
                        const dy = Math.abs(y) - (h/2 - r);
                        let inside = false;
                        if (dx <= 0 || dy <= 0) inside = true;
                        else if (dx * dx + dy * dy <= r * r) inside = true;

                        if (inside) {
                            // Bezel vs Screen logic
                            const margin = 4;
                            const isScreen = Math.abs(x) < (w/2 - margin) && Math.abs(y) < (h/2 - margin);
                            
                            // Front face (Screen has higher density)
                            if (isScreen) {
                                // Dynamic Island cutout
                                const isIsland = Math.abs(x) < 12 && y > h/2 - 15 && y < h/2 - 10;
                                if (!isIsland) candidates.push([x, y, d/2]);
                            } else {
                                // Reduce bezel density with sampling
                                if (Math.random() < SAMPLE_RATE) candidates.push([x, y, d/2]);
                            }

                            // Back face
                            const isCameraBump = x < -w/2 + 30 && y > h/2 - 40;
                            if (isCameraBump) {
                                candidates.push([x, y, -d/2 - 2]); // Camera bump sticking out
                                // Lenses
                                const l1 = Math.pow(x - (-w/2 + 12), 2) + Math.pow(y - (h/2 - 12), 2) < 16;
                                const l2 = Math.pow(x - (-w/2 + 12), 2) + Math.pow(y - (h/2 - 28), 2) < 16;
                                if (l1 || l2) candidates.push([x, y, -d/2 - 4]);
                            } else {
                                // Algar Logo on the back
                                const logoX = 0, logoY = -10, logoSize = 15;
                                const distFromLogoCenter = Math.sqrt(Math.pow(x - logoX, 2) + Math.pow(y - logoY, 2));
                                const isLogo = distFromLogoCenter < logoSize && distFromLogoCenter > logoSize - 3;
                                const isLogoInner = Math.abs(x) < 2 && Math.abs(y - logoY) < logoSize;
                                
                                if (isLogo || isLogoInner) {
                                    candidates.push([x, y, -d/2 - 1.5]);
                                } else {
                                    if (Math.random() < SAMPLE_RATE) candidates.push([x, y, -d/2]);
                                }
                            }
                        }
                    }
                }
                
                // Sides/Edges
                for (let y = -h/2; y <= h/2; y += density * 1.5) {
                    const dy = Math.abs(y) - (h/2 - r);
                    const curX = dy > 0 ? (w/2 - r) + Math.sqrt(Math.max(0, r*r - dy*dy)) : w/2;
                    for (let z = -d/2; z <= d/2; z += density) {
                        // sample edges sparsely
                        if (Math.random() < SAMPLE_RATE) {
                            candidates.push([curX, y, z]);
                            candidates.push([-curX, y, z]);
                        }
                    }
                }
                
                // Stratified sampling to avoid holes
                return stratifiedSample(candidates, density, SAMPLE_RATE, 1, 2000);
            }
            
            // Helper: Generate realistic house shape
            function generateBuildingPoints() {
                const candidates = [];
                // Aggressive low spacing for testing
                const density = 1.0;
                
                const drawStructure = (xOff, yOff, zOff, w, h, d, hasRoof = true) => {
                    for (let x = -w/2; x <= w/2; x += density) {
                        for (let y = -h/2; y <= h/2; y += density) {
                            for (let z = -d/2; z <= d/2; z += density) {
                                const isSurface = Math.abs(x - w/2) < 1 || Math.abs(x + w/2) < 1 || 
                                                 Math.abs(y - h/2) < 1 || Math.abs(y + h/2) < 1 || 
                                                 Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1;
                                if (isSurface) {
                                    // Main Door
                                    const isFront = Math.abs(z - d/2) < 1 && xOff === 0;
                                    const isDoor = isFront && Math.abs(x) < 8 && y < -5;
                                    if (isDoor) continue;
                                    
                                    // Windows
                                    const isWindow = (Math.abs(x) % 30 > 8 && Math.abs(x) % 30 < 22 && Math.abs(y) < 10);
                                    if (isWindow && !isDoor) continue;

                                    if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, y + yOff, z + zOff]);
                                }
                            }
                        }
                    }
                    if (hasRoof) {
                        const roofH = 35;
                        for (let z = -d/2 - 4; z <= d/2 + 4; z += density) {
                            for (let x = -w/2 - 4; x <= w/2 + 4; x += density) {
                                const ry = h/2 + roofH * (1 - Math.abs(x) / (w/2 + 4));
                                if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, ry + yOff, z + zOff]);
                                if (Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1) {
                                    for (let gy = h/2; gy < ry; gy += density) {
                                        if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, gy + yOff, z + zOff]);
                                    }
                                }
                            }
                        }
                    }
                };

                drawStructure(0, -10, 0, 70, 50, 60, true);  // Main House
                drawStructure(50, -20, 5, 35, 35, 45, true); // Side wing
                
                // Chimney
                for (let x = -25; x < -15; x += density) {
                    for (let z = -25; z < -15; z += density) {
                        for (let y = 10; y < 65; y += density) {
                            candidates.push([x, y, z]);
                        }
                    }
                }
                
                // Stratified sampling to avoid holes
                return stratifiedSample(candidates, density, SAMPLE_RATE, 1, 3000);
            }
            
            // Helper: Generate realistic semi-truck shape
            function generateTruckPoints() {
                const candidates = [];
                // Aggressive low spacing for testing
                const density = 1.0;
                
                const drawPart = (xOff, yOff, zOff, w, h, d, options = {}) => {
                    for (let x = -w/2; x <= w/2; x += density) {
                        for (let y = -h/2; y <= h/2; y += density) {
                            for (let z = -d/2; z <= d/2; z += density) {
                                const isSurface = Math.abs(x - w/2) < 1 || Math.abs(x + w/2) < 1 || 
                                                 Math.abs(y - h/2) < 1 || Math.abs(y + h/2) < 1 || 
                                                 Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1;
                                if (isSurface) {
                                    // Window cutout logic
                                    if (options.isCab && x < -w/2 + 2 && Math.abs(z) < d/2 - 4 && y > 0) {
                                        if (Math.abs(z) > d/2 - 6 || y > h/2 - 3) candidates.push([x + xOff, y + yOff, z + zOff]);
                                        continue;
                                    }
                                    if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, y + yOff, z + zOff]);
                                }
                            }
                        }
                    }
                };

                // Cab
                drawPart(-45, -5, 0, 35, 50, 38, { isCab: true });
// Mirrors (sparser)
                [1, -1].forEach(side => {
                    for (let y = 0; y < 15; y += 5) {
                        if (Math.random() < SAMPLE_RATE) candidates.push([-58, y, side * 22]);
                    }
                });
                // Exhausts (sparser)
                for (let y = -10; y < 45; y += 6) {
                    if (Math.random() < SAMPLE_RATE) candidates.push([-30, y, 16], [-30, y, -16]);
                }

                // Cargo Trailer
                drawPart(25, 5, 0, 100, 65, 42);
                
                // Chassis and Fuel Tanks (sparser)
                for (let x = -60; x < 65; x += 8) {
                    if (Math.random() < SAMPLE_RATE) candidates.push([x, -25, 12], [x, -25, -12]);
                    if (x > -35 && x < -15) {
                        for (let angle = 0; angle < Math.PI * 2; angle += 1.0) {
                            if (Math.random() < SAMPLE_RATE) candidates.push([x, -22 + Math.cos(angle)*8, 22 + Math.sin(angle)*8]);
                            if (Math.random() < SAMPLE_RATE) candidates.push([x, -22 + Math.cos(angle)*8, -22 - Math.sin(angle)*8]);
                        }
                    }
                }
                
                // 4 Wheels (sparser dz and angle steps)
                const wheelPos = [[-55, -30], [50, -30]];
                wheelPos.forEach(([wx, wy]) => {
                    for (let side = -1; side <= 1; side += 2) {
                        const zCenter = side * 24;
                        for (let dz = -5; dz <= 5; dz += 4) {
                            for (let angle = 0; angle < Math.PI * 2; angle += 0.8) {
                                const r = 13;
                                if (Math.random() < SAMPLE_RATE) candidates.push([wx + Math.cos(angle) * r, wy + Math.sin(angle) * r, zCenter + dz]);
                            }
                        }
                    }
                });
                
                // Stratified sampling to avoid holes
                return stratifiedSample(candidates, density, SAMPLE_RATE, 1, 3500);
            }
            
            // Create Three.js scene for each canvas
            document.querySelectorAll('.card-3d-viz').forEach(canvas => {
                const shape = canvas.dataset.shape;
                const container = canvas.parentElement;

                const initViz = (w, h) => {
                    if (canvas.dataset.loaded === "true") return;
                    canvas.dataset.loaded = "true";
                    
                    try {
                        console.log(`Initializing ${shape} viz: ${w}x${h}`);
                        const scene = new THREE.Scene();
                        const camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 2000);
                        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
                        
                        renderer.setPixelRatio(window.devicePixelRatio || 1);
                        renderer.setSize(w, h);
                        camera.position.z = 250;

                        // Mapping shapes to GLB files
                        const glbMap = {
                            'phone': 'Phone.glb',
                            'building': 'Farm house.glb',
                            'truck': 'Truck.glb'
                        };

                        let object3D = null;
                        const glbFile = glbMap[shape];

                        if (glbFile) {
                            const loader = new GLTFLoader();
                            loader.load(glbFile, (gltf) => {
                                const model = gltf.scene || gltf.scenes[0];
                                
                                // 1. Normalize model scale BEFORE sampling to ensure grid consistency
                                const box = new THREE.Box3().setFromObject(model);
                                const size = new THREE.Vector3(); box.getSize(size);
                                const maxDim = Math.max(size.x, size.y, size.z);
                                const preScale = 160 / maxDim; // Reduced by 20% (was 200)
                                model.scale.setScalar(preScale);
                                model.updateMatrixWorld(true);
                                
                                // 2. Convert Mesh to Points with an "organized" grid feel
                                const pointsArr = [];
                                const gridSet = new Set();
                                const gridSize = shape === 'phone' ? 2.0 : 2.6; // Increased spacing (was 1.5/2.0)
                                
                                const meshes = [];
                                model.traverse(c => { if (c.isMesh && c.geometry) meshes.push(c); });
                                
                                // Calculate total surface area for proportional distribution
                                let totalArea = 0;
                                const meshData = meshes.map(m => {
                                    if(!m.geometry.boundingBox) m.geometry.computeBoundingBox();
                                    const s = new THREE.Vector3();
                                    m.geometry.boundingBox.getSize(s);
                                    const area = 2 * (s.x * s.y + s.x * s.z + s.y * s.z);
                                    totalArea += area;
                                    return { mesh: m, area: area };
                                });

                                meshData.forEach(data => {
                                    const sampler = new MeshSurfaceSampler(data.mesh).build();
                                    const tempPos = new THREE.Vector3();
                                    const samplesForThisMesh = (70000 * data.area) / totalArea; // Reduced pool (was 90000)

                                    for (let i = 0; i < samplesForThisMesh; i++) {
                                        sampler.sample(tempPos);
                                        tempPos.applyMatrix4(data.mesh.matrixWorld);
                                        
                                        const gx = Math.round(tempPos.x / gridSize) * gridSize;
                                        const gy = Math.round(tempPos.y / gridSize) * gridSize;
                                        const gz = Math.round(tempPos.z / gridSize) * gridSize;
                                        
                                        const key = `${gx.toFixed(1)}|${gy.toFixed(1)}|${gz.toFixed(1)}`;
                                        if (!gridSet.has(key)) {
                                            gridSet.add(key);
                                            pointsArr.push(gx, gy, gz);
                                        }
                                    }
                                });

                                const geo = new THREE.BufferGeometry();
                                geo.setAttribute('position', new THREE.Float32BufferAttribute(pointsArr, 3));
                                geo.center(); 

                                // Final normalization
                                const finalScale = shape === 'phone' ? 0.9 : 1.1; 
                                geo.scale(finalScale, finalScale, finalScale);

                                const canvasCircle = document.createElement('canvas');
                                canvasCircle.width = 64; canvasCircle.height = 64;
                                const ctxC = canvasCircle.getContext('2d');
                                ctxC.beginPath(); ctxC.arc(32, 32, 30, 0, Math.PI * 2);
                                ctxC.fillStyle = '#ffffff'; ctxC.fill();

                                const tex = new THREE.CanvasTexture(canvasCircle);
                                tex.minFilter = THREE.LinearFilter;
                                tex.magFilter = THREE.LinearFilter;
                                tex.generateMipmaps = false;
                                tex.premultiplyAlpha = true;
                                tex.needsUpdate = true;

                                const mat = new THREE.PointsMaterial({
                                    size: shape === 'phone' ? 1.6 : 1.9,
                                    map: tex,
                                    color: 0x00ff88,
                                    transparent: true,
                                    opacity: 0.75,
                                    alphaTest: 0.02,
                                    depthWrite: false,
                                    depthTest: true,
                                    blending: THREE.NormalBlending
                                });

                                const pts = new THREE.Points(geo, mat);
                                
                                // Adjust starting orientation
                                pts.rotation.y = shape === 'phone' ? Math.PI : Math.PI * -0.2;
                                
                                scene.add(pts);
                                object3D = pts;
                            }, undefined, (err) => {
                                console.error('GLTF load error', err);
                                // Fallback to procedural if GLB fails
                                loadFallback(shape, scene, (pts) => { object3D = pts; });
                            });

                            let rotX = 0.3, rotY = shape === 'phone' ? Math.PI : 0.5;
                            let targetRotX = rotX, targetRotY = rotY;

                            container.addEventListener('mousemove', (e) => {
                                const rect = container.getBoundingClientRect();
                                const mouseX = ((e.clientX - rect.left) / w - 0.5) * Math.PI;
                                const mouseY = ((e.clientY - rect.top) / h - 0.5) * Math.PI * 0.5;
                                targetRotY = (shape === 'phone' ? Math.PI : 0.5) + mouseX;
                                targetRotX = 0.3 + mouseY;
                            });

                            container.addEventListener('mouseleave', () => {
                                targetRotX = 0.3; targetRotY = shape === 'phone' ? Math.PI : 0.5;
                            });

                            function animateGLB() {
                                requestAnimationFrame(animateGLB);
                                if (object3D) {
                                    rotX += (targetRotX - rotX) * 0.05;
                                    rotY += (targetRotY - rotY) * 0.05;
                                    object3D.rotation.x = rotX;
                                    object3D.rotation.y = rotY;
                                    const s = 0.98 + Math.sin(Date.now() * 0.0008) * 0.02;
                                    object3D.scale.set(s, s, s);
                                }
                                renderer.render(scene, camera);
                            }
                            animateGLB();

                        }

                        // Helper for fallbacks to avoid code duplication
                        function loadFallback(shape, scene, callback) {
                            let pointsData;
                            switch(shape) {
                                case 'phone': pointsData = generatePhonePoints(); break;
                                case 'building': pointsData = generateBuildingPoints(); break;
                                case 'truck': pointsData = generateTruckPoints(); break;
                                default: pointsData = generatePhonePoints();
                            }
                            const geo = new THREE.BufferGeometry();
                            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pointsData.flat()), 3));
                            const canvasCircle = document.createElement('canvas');
                            canvasCircle.width = 64; canvasCircle.height = 64;
                            const ctxC = canvasCircle.getContext('2d');
                            ctxC.beginPath(); ctxC.arc(32, 32, 30, 0, Math.PI * 2);
                            ctxC.fillStyle = '#ffffff'; ctxC.fill();
                            const tex = new THREE.CanvasTexture(canvasCircle);
                            tex.minFilter = THREE.LinearFilter;
                            tex.magFilter = THREE.LinearFilter;
                            tex.generateMipmaps = false;
                            tex.premultiplyAlpha = true;
                            tex.needsUpdate = true;
                            const mat = new THREE.PointsMaterial({ size: 2.4, map: tex, color: 0x00ff88, transparent: true, opacity: 0.75, alphaTest: 0.02, depthWrite: false, depthTest: true, blending: THREE.NormalBlending });
                            const pts = new THREE.Points(geo, mat);
                            scene.add(pts);
                            callback(pts);
                        }

                        window.addEventListener('resize', () => {
                            const nw = container.clientWidth, nh = container.clientHeight;
                            if (nw > 0 && nh > 0) {
                                renderer.setSize(nw, nh);
                                camera.aspect = nw / nh;
                                camera.updateProjectionMatrix();
                            }
                        });
                    } catch (e) { console.error(e); }
                };

                const ro = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            initViz(width, height);
                            ro.disconnect();
                        }
                    }
                });
                ro.observe(container);
            });
        })();

        // Three.js Background - Positioned & Rounded
        function initBg() {
            const container = document.getElementById('bg-canvas');
            if(!container) return;
            
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x030303, 0.03);

            const getDims = () => ({
                w: container.clientWidth,
                h: container.clientHeight
            });
            let dims = getDims();

            const camera = new THREE.PerspectiveCamera(75, dims.w / dims.h, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
            renderer.setSize(dims.w, dims.h);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);

            // Geometry - Sharp Architectural Cubes (Edges only)
            const geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const edgesGeometry = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.85
            });
            
            const cubes = [];
            const group = new THREE.Group();
            
            // Cluster Logic: Rubik-style Grid (Organized but fractured)
            const gridSize = 4;
            const spacing = 1.4;
            for(let x=0; x<gridSize; x++) {
                for(let y=0; y<gridSize; y++) {
                    for(let z=0; z<gridSize; z++) {
                        // Skip some to create "voids" in the rubik structure
                        if(Math.random() < 0.4) continue;

                        const cube = new THREE.LineSegments(edgesGeometry, material.clone());
                        
                        // Base Grid Position
                        let px = (x - (gridSize-1)/2) * spacing;
                        let py = (y - (gridSize-1)/2) * spacing;
                        let pz = (z - (gridSize-1)/2) * spacing;

                        // "Fractured" logic: Spread some cubes away from the center
                        const distanceFactor = Math.random();
                        if(distanceFactor > 0.7) {
                            // Small outward nudge to keep them close but distinct
                            const dir = new THREE.Vector3(px, py, pz).normalize();
                            if(dir.length() === 0) dir.set(1, 1, 1).normalize();
                            
                            const pushDistance = 0.6 + Math.random() * 0.8; 
                            px += dir.x * pushDistance;
                            py += dir.y * pushDistance;
                            pz += dir.z * pushDistance;
                        }

                        cube.position.set(px, py, pz);
                        cube.rotation.set(0, 0, 0); // All cubes share the same orientation
                        group.add(cube);
                        cubes.push(cube);
                    }
                }
            }
            
            // Reposition beside text
            const updateGroupPos = () => {
                group.position.x = dims.w > 768 ? 4 : 0;
                group.position.y = dims.w > 768 ? 0 : -2;
            };
            updateGroupPos();
            scene.add(group);

            camera.position.z = 12;

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let selectedObject = null;
            let isDragging = false;
            const dragPlane = new THREE.Plane();
            const planeNormal = new THREE.Vector3(0, 0, 1);
            const intersection = new THREE.Vector3();
            let offset = new THREE.Vector3();

            const updateMouse = (e) => {
                const rect = container.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / dims.w) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / dims.h) * 2 + 1;
            };

            container.addEventListener('mousemove', (e) => {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);

                if (isDragging && selectedObject) {
                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        // Move in group space
                        const localIntersection = group.worldToLocal(intersection.clone().sub(offset));
                        selectedObject.position.copy(localIntersection);
                    }
                    return;
                }

                const intersects = raycaster.intersectObjects(cubes);
                document.body.style.cursor = intersects.length > 0 ? 'grab' : 'crosshair';
            });

            container.addEventListener('mousedown', (e) => {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubes);

                if (intersects.length > 0) {
                    isDragging = true;
                    selectedObject = intersects[0].object;
                    
                    planeNormal.copy(camera.position).normalize();
                    const worldPos = new THREE.Vector3();
                    selectedObject.getWorldPosition(worldPos);
                    dragPlane.setFromNormalAndCoplanarPoint(planeNormal, worldPos);
                    
                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        offset.copy(intersection).sub(worldPos);
                    }
                    
                    document.body.style.cursor = 'grabbing';
                    selectedObject.material.color.setHex(0xffffff); // Highlight white
                }
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                if(selectedObject) {
                    selectedObject.material.color.setHex(0x00ff88); // Reset to green
                    selectedObject = null;
                }
            });

            window.addEventListener('resize', () => {
                dims = getDims();
                camera.aspect = dims.w / dims.h;
                camera.updateProjectionMatrix();
                renderer.setSize(dims.w, dims.h);
                updateGroupPos();
            });

            function animate() {
                requestAnimationFrame(animate);
                // ALWAYS rotate to maintain momentum (slower)
                group.rotation.y += 0.001;
                group.rotation.z += 0.0003;
                renderer.render(scene, camera);
            }
            animate();
        }
        
        initBg();
        
        // --- BG Particles & Parallax ---
        (function initParticles(){
            const container = document.getElementById('bg-canvas');
            if(!container) return;

            // canvas for particles
            const canvas = document.createElement('canvas');
            canvas.id = 'bg-particles';
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            let DPR = Math.max(1, window.devicePixelRatio || 1);
            let W = 0, H = 0;
            function resize() {
                W = canvas.width = Math.max(300, container.clientWidth) * DPR;
                H = canvas.height = Math.max(300, container.clientHeight) * DPR;
                canvas.style.width = (W / DPR) + 'px';
                canvas.style.height = (H / DPR) + 'px';
            }
            window.addEventListener('resize', resize);
            resize();

            const PCOUNT = 80;
            const particles = [];
            for(let i=0;i<PCOUNT;i++) particles.push({ x: Math.random()*W, y: Math.random()*H, r: (Math.random()*1.6+0.6)*DPR, vx: (Math.random()-0.5)*0.25, vy: (Math.random()-0.5)*0.25, a: (Math.random()*0.6+0.15) });

            let mx = 0, my = 0, tx = 0, ty = 0;
            container.addEventListener('mousemove', e => {
                const rect = container.getBoundingClientRect();
                mx = ((e.clientX - rect.left) / rect.width - 0.5);
                my = ((e.clientY - rect.top) / rect.height - 0.5);
            });
            window.addEventListener('scroll', () => {
                ty = window.scrollY * 0.01;
            });

            function draw() {
                ctx.clearRect(0,0,W,H);
                tx += (mx*30 - tx) * 0.06; // smooth
                ty += (ty - ty) * 0.02; // no-op but reserved for future

                for(let p of particles){
                    p.x += p.vx; p.y += p.vy;
                    if(p.x < -50) p.x = W + 50;
                    if(p.x > W + 50) p.x = -50;
                    if(p.y < -50) p.y = H + 50;
                    if(p.y > H + 50) p.y = -50;

                    ctx.beginPath();
                    ctx.fillStyle = `rgba(0,255,136,${p.a})`;
                    ctx.arc(p.x + mx*12*DPR, p.y + my*12*DPR, p.r, 0, Math.PI*2);
                    ctx.fill();
                }
                requestAnimationFrame(draw);
            }
            draw();

            // parallax transform for bg-canvas
            let px = 0, py = 0;
            function updateParallax(){
                px += (mx * 8 - px) * 0.06;
                py += (my * 8 - py) * 0.06;
                container.style.transform = `translate3d(${px}px, ${py}px, 0)`;
                requestAnimationFrame(updateParallax);
            }
            updateParallax();
        })();

        // Reveal, arrow micro-interactions, tilt & scroll parallax
        (function initRevealAndTilt(){
            // Intersection Observer for reveal animations
            const io = new IntersectionObserver((entries) => {
                entries.forEach((entry, idx) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                        const delay = (entry.target.datasetRevealIndex || 0) * 60;
                        entry.target.style.transitionDelay = (delay) + 'ms';
                        io.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.12 });

            const workCards = Array.from(document.querySelectorAll('.work-card, .section-heading'));
            workCards.forEach((el, i) => {
                el.datasetRevealIndex = i;
                el.classList.add('reveal');
                io.observe(el);
            });

        })();

        // --- INTERACTIVE NODE GRAPH (V4.5 FIXED) ---
        // Load the 3d-force-graph library dynamically
        function loadGraphLibrary() {
            return new Promise((resolve, reject) => {
                if (typeof ForceGraph3D !== 'undefined') {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/3d-force-graph@1.70.0';
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load 3d-force-graph'));
                document.head.appendChild(script);
            });
        }

        function initNodeGraph() {
            const elem = document.getElementById('node-graph-viz');
            if (!elem) {
                console.error('Graph container not found');
                return;
            }

            // Wait until element has dimensions
            if (elem.clientWidth === 0 || elem.clientHeight === 0) {
                console.log('Graph waiting for layout... Will retry.');
                setTimeout(initNodeGraph, 300);
                return;
            }

            console.log(`Graph container ready: ${elem.clientWidth}x${elem.clientHeight}`);

            if (typeof ForceGraph3D === 'undefined') {
                console.error('ForceGraph3D not available');
                elem.innerHTML = "<div class='graph-loading'>[GRAPH_LIB_ERROR] ForceGraph3D not loaded</div>";
                return;
            }

            // Create glow texture for nodes
            function createGlowTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            // Spread nodes evenly throughout 3D space like a star field
            // Using spherical distribution with randomization for natural look
            
            // Helper function to generate points on a sphere with variation
            function sphericalPoint(radius, indexRatio, variation = 30) {
                const phi = Math.acos(-1 + (2 * indexRatio));
                const theta = Math.sqrt((100) * Math.PI) * phi;
                
                const r = radius + (Math.random() - 0.5) * variation;
                const x = r * Math.cos(theta) * Math.sin(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(phi);
                
                return { x, y, z };
            }
            
            const allSkills = [
                // Research Methods
                { name: "Generative Research", type: "methods" },
                { name: "Evaluative Research", type: "methods" },
                { name: "Mixed Methods", type: "methods" },
                { name: "User Interviews", type: "methods" },
                { name: "Contextual Inquiry", type: "methods" },
                { name: "Usability Testing", type: "methods" },
                { name: "Card Sorting", type: "methods" },
                { name: "A/B Testing", type: "methods" },
                { name: "Analytics", type: "methods" },
                { name: "Heatmaps", type: "methods" },
                { name: "Personas", type: "artifacts" },
                { name: "JTBD", type: "artifacts" },
                { name: "Empathy Maps", type: "artifacts" },
                
                // Product Strategy
                { name: "Product Discovery", type: "decisions" },
                { name: "Value Proposition", type: "decisions" },
                { name: "OKRs", type: "decisions" },
                { name: "Roadmapping", type: "decisions" },
                { name: "North Star Metrics", type: "decisions" },
                { name: "Product Vision", type: "decisions" },
                { name: "Business Models", type: "decisions" },
                { name: "Competitive Analysis", type: "decisions" },
                { name: "Market Research", type: "decisions" },
                
                // Interaction Design
                { name: "Interaction Patterns", type: "artifacts" },
                { name: "Microinteractions", type: "artifacts" },
                { name: "Motion Design", type: "artifacts" },
                { name: "State Management", type: "artifacts" },
                { name: "Navigation Models", type: "artifacts" },
                { name: "Form Design", type: "artifacts" },
                
                // Information Architecture
                { name: "Site Maps", type: "artifacts" },
                { name: "Content Hierarchies", type: "artifacts" },
                { name: "Taxonomies", type: "artifacts" },
                { name: "Navigation Structures", type: "artifacts" },
                { name: "Wayfinding", type: "artifacts" },
                { name: "Search & Filtering", type: "artifacts" },
                
                // Usability & Accessibility
                { name: "Heuristics", type: "methods" },
                { name: "WCAG", type: "methods" },
                { name: "Inclusive Design", type: "methods" },
                { name: "Keyboard Navigation", type: "methods" },
                { name: "Screen Reader Support", type: "methods" },
                
                // Design Process
                { name: "Problem Framing", type: "methods" },
                { name: "Brainstorming", type: "methods" },
                { name: "Design Studios", type: "methods" },
                { name: "Prototype Testing", type: "methods" },
                { name: "Design Reviews", type: "methods" },
                { name: "Iterative Refinement", type: "methods" },
                
                // Design Systems
                { name: "Design Systems", type: "meta" },
                { name: "Component Libraries", type: "artifacts" },
                { name: "Pattern Libraries", type: "artifacts" },
                { name: "Design Tokens", type: "artifacts" },
                { name: "Governance Models", type: "meta" },
                
                // Metrics
                { name: "KPIs", type: "outcomes" },
                { name: "Activation", type: "outcomes" },
                { name: "Retention", type: "outcomes" },
                { name: "Conversion Rate", type: "outcomes" },
                { name: "Feature Adoption", type: "outcomes" },
                
                // Prototyping
                { name: "Wireframes", type: "artifacts" },
                { name: "Interactive Prototypes", type: "artifacts" },
                
                // Systems Thinking
                { name: "Feedback Loops", type: "meta" },
                { name: "Trade-offs", type: "meta" },
                { name: "Constraints", type: "meta" },
                { name: "Dependencies", type: "meta" },
                
                // Collaboration
                { name: "Product Management", type: "collab" },
                { name: "Engineering", type: "collab" },
                { name: "Workshop Facilitation", type: "collab" },
                { name: "Stakeholder Management", type: "collab" },
                
                // Ethics
                { name: "Privacy by Design", type: "ethics" },
                { name: "Consent", type: "ethics" },
                { name: "Dark Patterns Awareness", type: "ethics" },
                { name: "Bias Mitigation", type: "ethics" },
                
                // Additional Skills
                { name: "Design Critique", type: "collab" },
                { name: "Storytelling", type: "collab" },
                { name: "User Flows", type: "artifacts" },
                { name: "Journey Mapping", type: "artifacts" },
                { name: "Service Blueprints", type: "artifacts" },
                { name: "Tree Testing", type: "methods" },
                { name: "Guerilla Testing", type: "methods" },
                { name: "Cognitive Walkthrough", type: "methods" },
                { name: "Funnel Analysis", type: "methods" },
                { name: "Cohort Analysis", type: "methods" }
            ];
            
            // Generate nodes with spherical distribution
            const allNodes = allSkills.map((skill, index) => {
                const pos = sphericalPoint(120, index / allSkills.length, 30);
                return {
                    id: skill.name,
                    group: skill.type,
                    val: 10,
                    ...pos
                };
            });

            // Connect every node to its neighbors to form a cohesive web
            const links = [];
            allNodes.forEach((node, i) => {
                // Find 2-3 nearest neighbors based on spherical coordinates to create a mesh feel
                const neighbors = allNodes
                    .map((n, idx) => ({ id: n.id, dist: Math.hypot(n.x - node.x, n.y - node.y, n.z - node.z), idx }))
                    .filter(n => n.id !== node.id)
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, 2);
                
                neighbors.forEach(nb => {
                    // Avoid duplicate links
                    if (i < nb.idx) links.push({ source: node.id, target: nb.id });
                });
            });

            const data = {
                nodes: allNodes,
                links: links
            }; 

            try {
                // Clear loading indicator
                elem.innerHTML = '<div class="graph-loading">[RENDERING...]</div>';
                
                console.log('Initializing ForceGraph3D...');
                let isRotating = true;
                let hoveredNode = null;
                let currentHoverId = null; // For dynamic link highlighting
                const nodeObjects = new Map();
                
                // Create custom node object with label as text sprite
                const Graph = ForceGraph3D()(elem)
                    .graphData(data)
                    .backgroundColor('rgba(0, 0, 0, 0)')
                    .showNavInfo(false)
                    .linkWidth(0.6)
                    .linkColor(link => {
                        const s = (link.source && link.source.id) || link.source;
                        const t = (link.target && link.target.id) || link.target;
                        return (currentHoverId && (s === currentHoverId || t === currentHoverId))
                            ? 'rgba(0,255,136,0.8)'
                            : 'rgba(0,255,136,0.15)';
                    })
                    .linkOpacity(0.2)
                    .nodeLabel(null) // Disable default tooltips
                    .width(elem.clientWidth)
                    .height(elem.clientHeight)
                    .enableNodeDrag(false)
                    .cooldownTicks(0)
                    .nodeThreeObject(node => {
                        const group = new THREE.Group();

                        // 1. The Core Cube (now emits light)
                        const size = 2.0;
                        const geometry = new THREE.BoxGeometry(size, size, size);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x00ff88,
                            transparent: true,
                            opacity: 0.7
                        });
                        const cube = new THREE.Mesh(geometry, material);
                        group.add(cube);

                        // 2. The Text Label (Always facing camera)
                        // Using a canvas-based sprite for clean, sharp text
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        context.font = 'bold 24px monospace';
                        context.fillStyle = '#ffffff';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(node.id.toUpperCase(), 128, 32);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
                        const label = new THREE.Sprite(spriteMat);
                        label.position.set(0, 10, 0); // Position above node
                        label.scale.set(30, 7.5, 1);
                        group.add(label);

                        // 3. Selective Glow
                        const glowTex = createGlowTexture();
                        const glowMat = new THREE.SpriteMaterial({
                            map: glowTex,
                            color: 0x00ff88,
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending
                        });
                        const glow = new THREE.Sprite(glowMat);
                        glow.scale.set(size * 4, size * 4, 1);
                        group.add(glow);

                        group.userData = { cube, label, glow, originalOpacity: 0.7 };
                        nodeObjects.set(node.id, group);
                        return group;
                    })
                    .onNodeHover(node => {
                        // Reset all nodes
                        nodeObjects.forEach((obj, id) => {
                            obj.userData.cube.scale.set(1, 1, 1);
                            obj.userData.cube.material.opacity = 0.7;
                            obj.userData.label.scale.set(30, 7.5, 1);
                            obj.userData.label.material.opacity = 0.9;
                            obj.userData.glow.material.opacity = 0.3;
                        });

                        hoveredNode = node;
                        currentHoverId = node ? node.id : null; 
                        
                        // Stop rotation when hovering
                        isRotating = !!node ? false : true; 
                        elem.style.cursor = node ? 'pointer' : 'default';

                        // Highlight hovered node and refresh link colors
                        if (node) {
                            const group = nodeObjects.get(node.id);
                            if (group) {
                                group.userData.cube.scale.set(2, 2, 2);
                                group.userData.cube.material.opacity = 1.0;
                                group.userData.label.scale.set(40, 10, 1);
                                group.userData.label.material.opacity = 1.0;
                                group.userData.glow.material.opacity = 0.6;
                            }
                        }

                        // Trigger link color refresh
                        Graph.linkColor(Graph.linkColor());
                    });

                console.log('Graph created successfully');

                // Cinematic auto-rotation
                const distance = 320;
                let angle = 0;

                function rotateCamera() {
                    if (isRotating) {
                        angle += 0.0008; 
                        const camera = Graph.camera();
                        camera.position.x = distance * Math.sin(angle);
                        camera.position.z = distance * Math.cos(angle);
                        camera.position.y = 40 + Math.sin(angle * 0.5) * 15;
                        camera.lookAt(0, 0, 0);
                    }
                    requestAnimationFrame(rotateCamera);
                }
                
                Graph.controls().enabled = false;
                rotateCamera();

                // Force explicit dimensions
                setTimeout(() => {
                    Graph.width(elem.clientWidth);
                    Graph.height(elem.clientHeight);
                }, 100);

                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        if(width > 0 && height > 0) {
                            Graph.width(width);
                            Graph.height(height);
                        }
                    }
                });
                resizeObserver.observe(elem);

                // --- Node pulsing animation (radial breathing) ---
                const originalPos = new Map();
                data.nodes.forEach((n, idx) => {
                    originalPos.set(n.id, { x: n.x, y: n.y, z: n.z, offset: Math.random() * Math.PI * 2 });
                });

                (function animateNodes() {
                    const t = performance.now() / 1000;
                    data.nodes.forEach(n => {
                        const o = originalPos.get(n.id);
                        const k = 1 + Math.sin(t * 0.6 + o.offset) * 0.08; // +/-8%
                        n.x = o.x * k;
                        n.y = o.y * k;
                        n.z = o.z * k;
                    });
                    Graph.graphData(data);
                    requestAnimationFrame(animateNodes);
                })();
                
            } catch (e) {
                console.error('Graph initialization error:', e);
                elem.innerHTML = `<div class='graph-loading'>[GRAPH_ERROR] ${e.message}</div>`;
            }
        }
        
        // Load library and initialize graph
        loadGraphLibrary()
            .then(() => {
                console.log('3d-force-graph library loaded successfully');
                // Wait for DOM layout
                setTimeout(initNodeGraph, 500);
            })
            .catch(err => {
                console.error('Failed to load graph library:', err);
                const elem = document.getElementById('node-graph-viz');
                if (elem) {
                    elem.innerHTML = "<div class='graph-loading'>[LIBRARY_LOAD_FAILED] Check console</div>";
                }
            });
    </script>

    <!-- Background Animation Script -->
    <script type="module">
        import * as THREE from 'three';

        // Updated ID to avoid conflict with Hero Cubes
        const canvas = document.getElementById('bg-wave-canvas');
        const parent = canvas.parentElement;
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        
        function updateSize() {
            const w = parent.clientWidth;
            const h = parent.clientHeight;
            renderer.setSize(w, h);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            if (camera) {
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            }
        }

        const scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x050505, 0.0015); 

        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.z = 50; 
        camera.position.y = 15;
        camera.rotation.x = -0.3;

        updateSize();

        const geometry = new THREE.BufferGeometry();
        // Waves
        const count = 2500;
        const positions = new Float32Array(count * 3);
        const originalPositions = new Float32Array(count * 3);
        
        // Spread particles in a grid/plane
        let i = 0;
        const size2 = 180;
        const gap = 3.5;
        const columns = Math.sqrt(count);
        
        for (let x = 0; x < columns; x++) {
            for (let z = 0; z < columns; z++) {
                // Centered grid
                const px = (x * gap) - (columns * gap) / 2;
                const pz = (z * gap) - (columns * gap) / 2;
                
                positions[i] = px;
                positions[i+1] = 0; // Y
                positions[i+2] = pz;
                
                originalPositions[i] = px;
                originalPositions[i+1] = 0;
                originalPositions[i+2] = pz;

                i += 3;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            size: 0.15,
            color: 0x00ff88, // Accent color
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            const time = clock.getElapsedTime() * 0.5;

            // Wave effect
            const pos = geometry.attributes.position.array;
            for(let j=0; j < count; j++) {
                const x = originalPositions[j*3];
                const z = originalPositions[j*3 + 2];
                // Sine wave based on x, z and time
                pos[j*3 + 1] = (Math.sin(x * 0.05 + time) * 3) + (Math.cos(z * 0.05 + time) * 3); 
            }
            geometry.attributes.position.needsUpdate = true;

            // Gentle rotation
            particles.rotation.y = time * 0.02;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- Icosahedron Button Logic ---
        const icoButtons = document.querySelectorAll('.ico-btn');
        const icoScenes = [];

        icoButtons.forEach(btn => {
            const canvas = btn.querySelector('.ico-canvas');
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(100, 100);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            camera.position.z = 6; // Moved back for more room

            // Wireframe Icosahedron
            const geometry = new THREE.IcosahedronGeometry(1.5, 1); // Reduced size
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.4 
            });
            const mesh = new THREE.LineSegments(edges, material);
            scene.add(mesh);

            // Inner solid but very faint icosahedron for volume
            const innerGeo = new THREE.IcosahedronGeometry(1.45, 0); // Reduced size
            const innerMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.05
            });
            const innerMesh = new THREE.Mesh(innerGeo, innerMat);
            scene.add(innerMesh);

            icoScenes.push({ btn, scene, camera, renderer, mesh, innerMesh });
        });

        function animateIcos() {
            icoScenes.forEach(item => {
                const isHovered = item.btn.matches(':hover');
                const speed = isHovered ? 0.02 : 0.005;
                
                item.mesh.rotation.y += speed;
                item.mesh.rotation.z += speed * 0.5;
                item.innerMesh.rotation.y += speed;
                item.innerMesh.rotation.z += speed * 0.5;

                // Scale effect on hover
                const targetScale = isHovered ? 1.2 : 1.0;
                item.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                item.innerMesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                
                // Opacity effect
                item.mesh.material.opacity = THREE.MathUtils.lerp(item.mesh.material.opacity, isHovered ? 0.8 : 0.4, 0.1);

                item.renderer.render(item.scene, item.camera);
            });
            requestAnimationFrame(animateIcos);
        }
        animateIcos();

        // Resize
        window.addEventListener('resize', updateSize);

        // --- Logo Geometry Animation ---
        const logoCanvas = document.querySelector('.logo-canvas');
        if (logoCanvas) {
            const logoRenderer = new THREE.WebGLRenderer({ canvas: logoCanvas, alpha: true, antialias: true });
            logoRenderer.setSize(36, 36);
            logoRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const logoScene = new THREE.Scene();
            const logoCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            logoCamera.position.z = 4;

            // Soft lighting for subtle speculars
            const la = new THREE.AmbientLight(0xffffff, 0.6);
            logoScene.add(la);
            const lp = new THREE.PointLight(0x00ff88, 0.6, 10);
            lp.position.set(2, 2, 2);
            logoScene.add(lp);

            // Simple cube logo (restored)
            const logoGeometry = new THREE.BoxGeometry(1, 1, 1);
            const logoEdges = new THREE.EdgesGeometry(logoGeometry);
            const logoMaterial = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.95 });
            const logoShape = new THREE.LineSegments(logoEdges, logoMaterial);
            logoScene.add(logoShape);

            // Inner faint cube for volume
            const innerLogoGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const innerLogoMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff88, transparent: true, opacity: 0.08, metalness: 0.2, roughness: 0.6 });
            const innerLogoCube = new THREE.Mesh(innerLogoGeometry, innerLogoMaterial);
            logoScene.add(innerLogoCube);

            // Scale down logo to fit beside content (increased slightly)
            const LOGO_SCALE = 0.72;
            logoShape.scale.set(LOGO_SCALE, LOGO_SCALE, LOGO_SCALE);
            innerLogoCube.scale.set(LOGO_SCALE, LOGO_SCALE, LOGO_SCALE);

            function animateLogo() {
                const time = Date.now() * 0.001;
                // Calm rotation
                logoShape.rotation.x = time * 0.5;
                logoShape.rotation.y = time * 0.7;
                innerLogoCube.rotation.x = time * 0.5;
                innerLogoCube.rotation.y = time * 0.7;

                logoRenderer.render(logoScene, logoCamera);
                requestAnimationFrame(animateLogo);
            }
            animateLogo();

            // Align site logo with the page grid (keeps it visually in the left content column)
            const siteLogoEl = document.querySelector('.site-logo');
            const grid = document.querySelector('.grid-container');

            // Ensure the logo is not nested inside the HUD (or any transformed ancestor).
            // If it is, move it to document.body so it behaves relative to the document (page) instead of the viewport.
            function separateLogoIfNeeded() {
                if (!siteLogoEl) return;
                const offendingAncestor = siteLogoEl.closest('.hud-nav, [style*="transform"], [style*="backdrop-filter"], [style*="will-change"]');
                if (offendingAncestor && offendingAncestor !== document.body) {

                    document.body.appendChild(siteLogoEl);
                    // Use absolute positioning so the logo sits at a fixed document coordinate (scroll moves it along with page)
                    siteLogoEl.style.position = 'absolute';
                    siteLogoEl.style.zIndex = 10050;
                }
            }

            // Locking: once the initial position is computed, keep the logo at the same document coordinate
            // (so it stays at the beginning of the page and scroll will move it with the content)
            let logoLocked = false;
            function updateLogoAlignment() {
                if (!siteLogoEl) return;
                if (logoLocked) return; // already set

                // Ensure logo is separated first
                separateLogoIfNeeded();

                // Compute horizontal (content left) alignment (document coordinates)
                let leftViewport = 40;
                if (grid) {
                    const rect = grid.getBoundingClientRect();
                    leftViewport = Math.max(12, Math.round(rect.left + 12));
                }
                const leftDoc = leftViewport + window.scrollX;
                siteLogoEl.style.left = leftDoc + 'px';

                // Compute document-top lock: capture current document-relative top and set absolute
                const logoRect = siteLogoEl.getBoundingClientRect();
                const docTop = Math.round(logoRect.top + window.scrollY);

                // Set absolute document positioning and remove transitions
                siteLogoEl.style.transition = 'none';
                siteLogoEl.style.position = 'absolute';
                siteLogoEl.style.top = docTop + 'px';

                // Lock so future nav changes won't move the logo
                logoLocked = true;

            }
            updateLogoAlignment();

            // On resize we may need to update the *left* offset so the logo stays aligned with the content column
            window.addEventListener('resize', () => {
                if (!siteLogoEl) return;
                const rect = grid ? grid.getBoundingClientRect() : null;
                const leftViewport = rect ? Math.max(12, Math.round(rect.left + 12)) : 40;
                const leftDoc = leftViewport + window.scrollX;
                siteLogoEl.style.left = leftDoc + 'px';
            });

            // Logo stays fixed at its document start position; scrolling moves it with the page (no jitter)

            // site-logo debug removed — observer/logging was noisy in console.

            // Create nav indicator and entrance effects for links
            const navLinks = Array.from(document.querySelectorAll('.hud-link'));
            const indicator = document.createElement('div');
            indicator.className = 'nav-indicator';
            const navEl = document.querySelector('.hud-nav');
            if (navEl) navEl.appendChild(indicator);

            function updateIndicator(target) {
                if (!target) { indicator.style.width = '0'; return; }
                const rect = target.getBoundingClientRect();
                const navRect = navEl.getBoundingClientRect();
                const left = rect.left - navRect.left;
                indicator.style.left = left + 'px';
                indicator.style.width = rect.width + 'px';
            }

            // Ensure the logo re-aligns after the nav finishes animating (handles vertical translate)
            if (navEl) {
                navEl.addEventListener('transitionend', (e) => {
                    // Only react to opacity/transform changes on the nav
                    if (e.propertyName === 'transform' || e.propertyName === 'opacity') {
                        // Only re-align when the logo is not locked (development / debugging mode)
                        if (typeof logoLocked === 'undefined' || logoLocked === false) {
                            updateLogoAlignment();
                        }
                    }
                });
            }

            navLinks.forEach((link, i) => {
                link.addEventListener('mouseenter', (e) => updateIndicator(e.target));
                link.addEventListener('focus', (e) => updateIndicator(e.target));
                link.addEventListener('mouseleave', () => { indicator.style.width = '0'; });
                // entrance animation delay
                setTimeout(() => {
                    link.style.opacity = '1';
                    link.style.transform = 'translateY(0)';
                }, 80 * i);
            });

            window.addEventListener('resize', () => {
                updateIndicator(document.querySelector('.hud-link:hover') || document.querySelector('.hud-link.active'));
            });
        }

        // --- Nav Scroll Behavior ---
        let lastScrollY = window.scrollY;
        const nav = document.querySelector('.hud-nav');

        window.addEventListener('scroll', () => {
            const currentScrollY = window.scrollY;
            
            if (currentScrollY > lastScrollY && currentScrollY > 100) {
                // Scrolling down - hide nav
                nav.classList.add('nav-hidden');
            } else {
                // Scrolling up or at top - show nav
                nav.classList.remove('nav-hidden');
            }
            
            lastScrollY = currentScrollY;
        });
    </script>

    <script>
        (function(){
            const VAR_KEY = 'hero_ab_variant';
            const variants = [
                {
                    id: 'short-human',
                    badge: '',
                    title: 'I make products easier to use and faster to grow.',
                    sub: 'Product strategy • UX research • Interaction design • Cross-functional leadership',
                    micro: 'Open to senior product & design roles.',
                    cta: 'See work →'
                },
                {
                    id: 'concise-action',
                    badge: '',
                    title: 'Product Design that ships impact',
                    sub: 'I design product systems that increase conversion and retention for B2C apps.',
                    micro: 'Available for senior roles & contract work.',
                    cta: 'View case studies →'
                },
                {
                    id: 'warm-narrative',
                    badge: '',
                    title: 'I help teams turn messy problems into clear products.',
                    sub: 'Research-first product & interaction design. I focus on clarity, speed, and measurable outcomes.',
                    micro: 'Let’s talk about senior & advisory roles.',
                    cta: 'See impact →'
                },
                {
                    id: 'metric-human',
                    badge: '',
                    title: 'I make UX improvements that move the needle.',
                    sub: '1.9 → 3.0 app rating | -42% checkout friction. I solve the problems that move metrics.',
                    micro: 'Portfolio + case studies inside.',
                    cta: 'View impact →'
                }
            ];

            function pickVariant() {
                const url = new URL(window.location.href);
                const q = url.searchParams.get('ab');
                if (q) {
                    const v = variants.find(x => x.id === q);
                    if (v) {
                        localStorage.setItem(VAR_KEY, v.id);
                        console.log('A/B preview override to variant:', v.id);
                        return v;
                    }
                }
                const stored = localStorage.getItem(VAR_KEY);
                if (stored) {
                    const s = variants.find(x => x.id === stored);
                    if (s) return s;
                }
                // Random assign with equal weights
                const choice = variants[Math.floor(Math.random() * variants.length)];
                localStorage.setItem(VAR_KEY, choice.id);
                console.log('A/B assigned variant:', choice.id);
                return choice;
            }

            function renderVariant(v) {
                const b = document.getElementById('hero-badge');
                const t = document.getElementById('hero-title');
                const s = document.getElementById('hero-sub');
                const m = document.getElementById('hero-micro');
                const c = document.getElementById('hero-cta');
                if (!t || !s || !m || !c) return;
                // badge is optional; hide it when not provided
                if (b) {
                    if (v.badge) {
                        b.textContent = v.badge;
                        b.style.display = '';
                        b.removeAttribute('aria-hidden');
                    } else {
                        b.textContent = '';
                        b.style.display = 'none';
                        b.setAttribute('aria-hidden', 'true');
                    }
                }
                document.getElementById('hero-copy').setAttribute('data-ab-variant', v.id);
            }

            function animateVariantTransition(v) {
                const container = document.getElementById('hero-copy');
                if (!container) { renderVariant(v); return Promise.resolve(); }
                if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    renderVariant(v);
                    return Promise.resolve();
                }
                return new Promise(resolve => {
                    container.classList.add('hero-fade-out');
                    // allow CSS to animate
                    setTimeout(() => {
                        renderVariant(v);
                        // trigger reflow and fade in
                        void container.offsetWidth;
                        container.classList.remove('hero-fade-out');
                        container.classList.add('hero-fade-in');
                        setTimeout(() => {
                            container.classList.remove('hero-fade-in');
                            resolve();
                        }, 420);
                    }, 260);
                });
            }

            // Intro cycle removed: demo disabled. Variant cycling is manual via the 'V' hotkey.

            // Render on DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => { renderVariant(pickVariant());
                    // One-time decoding demo on first visit

                });
            } else {
                renderVariant(pickVariant());

            }

            // Keyboard quick-swap (dev): press V to cycle only the *titles* with a letter animation
            (function devHotKeysAndTitleCycle(){
                // Dev helper removed in production build (kept minimal stub)

                // Helper: split text into word-wrapped spans with inner letter spans (prevents mid-word breaks)
                function toSpannedHTML(text) {
                    const inner = text.split(/(\s+)/).map(part => {
                        if (/^\s+$/.test(part)) return '<span class="title-space">&nbsp;</span>';
                        const letters = Array.from(part).map(ch => `<span class="title-letter">${ch}</span>`).join('');
                        return `<span class="title-word">${letters}</span>`;
                    }).join('');
                    return `<span class="title-clip">${inner}</span>`;
                }

                // Original flip/glow animation renamed
                function animateTitleFlipTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    return new Promise(resolve => {
                        // Ensure current title is spanned
                        if (!el.querySelector('.title-letter')) {
                            el.innerHTML = toSpannedHTML(el.textContent || '');
                        }
                        const currentLetters = Array.from(el.querySelectorAll('.title-letter'));
                        // Exit animation staggered by letter
                        currentLetters.forEach((span, i) => {
                            setTimeout(() => span.classList.add('letter-exit'), i * 26);
                        });

                        // After exit, put new words/letters and animate them in with glow and word-group staggering
                        const exitDuration = currentLetters.length * 26 + 240;
                        setTimeout(() => {
                            el.innerHTML = toSpannedHTML(nextTitle);
                            const newLetters = Array.from(el.querySelectorAll('.title-letter'));
                            // Start in 'enter' state
                            newLetters.forEach(span => span.classList.add('letter-enter'));

                            if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                                // If reduced motion, just show text
                                newLetters.forEach(span => span.classList.remove('letter-enter'));
                                setTimeout(() => resolve(), 0);
                                return;
                            }

                            // stagger remove of enter class and add a brief glow as letters appear
                            let delay = 20;
                            Array.from(el.querySelectorAll('.title-word')).forEach((word) => {
                                const letters = Array.from(word.querySelectorAll('.title-letter'));
                                letters.forEach((span, j) => {
                                    setTimeout(() => {
                                        span.classList.remove('letter-enter');
                                        // quick glow on appearance
                                        span.classList.add('glow');
                                        setTimeout(() => span.classList.remove('glow'), 420);
                                    }, delay + j * 22);
                                });
                                delay += letters.length * 22 + 48;
                            });
                            const enterDuration = delay + 240;
                            setTimeout(() => resolve(), enterDuration);
                        }, exitDuration);
                    });
                }

                // Wrapper that dispatches to the selected effect
                function animateTitleTo(nextTitle) {
                    const effect = window._heroTitleEffect || localStorage.getItem('title_effect') || 'decode';
                    switch(effect) {
                        case 'glitch': return animateTitleGlitchTo(nextTitle);
                        case 'slice': return animateTitleSliceTo(nextTitle);
                        case 'particle': return animateTitleParticleTo(nextTitle);
                        case 'crt': return animateTitleCRTTo(nextTitle);
                        case 'decode': return animateTitleDecodeTo(nextTitle);
                        case 'plain':
                            document.getElementById('hero-title').innerHTML = nextTitle.replace('\n','<br>');
                            return Promise.resolve();
                        case 'flip':
                        default: return animateTitleFlipTo(nextTitle);
                    }
                }

                // ---- Glitch effect (simple layer-based) ----
                function animateTitleGlitchTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    const container = el.parentElement;
                    // create glitch layers
                    const glitchWrap = document.createElement('span');
                    glitchWrap.className = 'title-glitch';
                    const base = el.cloneNode(true);
                    const r = base.cloneNode(true);
                    r.className = 'glitch-layer layer-r';
                    const g = base.cloneNode(true);
                    g.className = 'glitch-layer layer-g';
                    glitchWrap.appendChild(base);
                    glitchWrap.appendChild(r);
                    glitchWrap.appendChild(g);
                    // replace title with wrap
                    container.replaceChild(glitchWrap, el);

                    return new Promise(resolve => {
                        // animate glitch then swap text
                        glitchWrap.classList.add('glitch-animate');
                        setTimeout(() => {
                            base.innerHTML = nextTitle.replace('\n','<br>');
                            r.innerHTML = base.innerHTML;
                            g.innerHTML = base.innerHTML;
                            // remove animation
                            glitchWrap.classList.remove('glitch-animate');
                            // unwrap: put base back into container
                            container.replaceChild(base, glitchWrap);
                            resolve();
                        }, 420);
                    });
                }

                // ---- Decoding / hacking style reveal (sequential letters) ----
                async function animateTitleDecodeTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    // A cleaner terminal-style charset
                    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<>[]/\\+=-_';

                    // Build spanned HTML (preserve words)
                    const words = nextTitle.split(/(\s+)/).map(part => {
                        if (/^\s+$/.test(part)) return '<span class="title-space">&nbsp;</span>';
                        const letters = Array.from(part).map(ch => `<span class="title-letter decoding">${charset.charAt(Math.floor(Math.random()*charset.length))}</span>`).join('');
                        return `<span class="title-word">${letters}</span>`;
                    }).join('');

                    el.innerHTML = `<span class="title-clip">${words}</span>`;

                    const letterSpans = Array.from(el.querySelectorAll('.title-letter'));
                    // FIX: Filter out whitespace from finals so they map correctly to .title-letter spans
                    const finals = Array.from(nextTitle).filter(ch => !/\s/.test(ch));

                    // Map final characters to letter spans
                    let fIdx = 0;
                    const targets = letterSpans.map(() => finals[fIdx++] || '');

                    // IMPORTANT: measure and lock each span width to the final character width so
                    // random decoding characters cannot change layout or cause word breaks.
                    await (async function lockLetterWidths(){
                        // Ensure hero webfont is loaded to avoid measuring with a fallback font which
                        // can yield different metrics and cause spacing issues on decode.
                        try {
                            const fontName = 'JetBrains Mono';
                            if (document.fonts && !document.fonts.check(`1em "${fontName}"`)) {
                                console.log('TITLE-DECODE-FONT: waiting for', fontName);
                                await Promise.race([
                                    document.fonts.load(`1em "${fontName}"`),
                                    new Promise(res => setTimeout(res, 300))
                                ]);
                                console.log('TITLE-DECODE-FONT: ready?', document.fonts.check(`1em "${fontName}"`));
                            } else {
                                console.log('TITLE-DECODE-FONT: already available');
                            }
                        } catch(e) { console.warn('TITLE-DECODE-FONT: check failed', e); }

                        // create a hidden measurement span matching the hero font
                        const style = getComputedStyle(el);
                        const font = style.font || 'bold 6vw JetBrains Mono, monospace';
                        const lineH = style.lineHeight || '1';
                        const letterSpacing = style.letterSpacing || 'normal';
                        
                        const meas = document.createElement('span');
                        meas.style.position = 'absolute'; 
                        meas.style.visibility = 'hidden'; 
                        meas.style.whiteSpace = 'pre'; 
                        meas.style.font = font; 
                        meas.style.lineHeight = lineH;
                        // Keep letter-spacing 'normal' during measurement to get the raw glyph width.
                        // The parent's letter-spacing will then pull these inline-blocks together naturally.
                        meas.style.letterSpacing = 'normal'; 
                        document.body.appendChild(meas);

                        // Ensure words don't break inside and preserve layout
                        Array.from(el.querySelectorAll('.title-word')).forEach(w => {
                            w.style.display = 'inline-block';
                            w.style.whiteSpace = 'nowrap';
                            w.style.verticalAlign = 'middle';
                        });

                        letterSpans.forEach((span, idx) => {
                            const ch = targets[idx] || ' ';
                            meas.textContent = ch;
                            const rect = meas.getBoundingClientRect();
                            const w = rect.width;
                            
                            // Use exact measured width and inline-block to preserve natural spacing/kerning.
                            // We avoid padding and min-width padding which were disrupting the compressed look.
                            span.style.display = 'inline-block';
                            span.style.textAlign = 'center';
                            span.style.width = w + 'px';
                            span.style.lineHeight = lineH; 
                            span.style.overflow = 'hidden'; 
                            span.style.verticalAlign = 'middle';
                            
                            // record locked width for runtime diagnostics
                            try { span._lockedWidth = w; } catch (e) { }
                        });
                        document.body.removeChild(meas);
                        // diagnostic snapshot of locked widths
                        try {
                            const widths = letterSpans.slice(0,10).map(s => parseFloat(s.style.width) || s.getBoundingClientRect().width);
                            const avg = Math.round(widths.reduce((a,b)=>a+b,0)/(widths.length||1));
                            console.log('TITLE-DECODE-LOCKED', { count: letterSpans.length, sample: widths, avg });
                        } catch(e) {}
                    })();

                    // Staggered overlapping decode with a "walking" cursor
                    return new Promise(resolve => {
                        let settled = 0;
                        const stagger = 25; 

                        letterSpans.forEach((span, i) => {
                            const startDelay = i * stagger;
                            setTimeout(() => {
                                // The "walking" cursor: remove from all, add to this one.
                                // Since they start in order, this keeps it at the "head" of the wave.
                                letterSpans.forEach(s => s.classList.remove('has-cursor'));
                                span.classList.add('active', 'has-cursor');
                                
                                // Increase steps so the "decode" scramble is actually visible
                                let steps = 6 + Math.floor(Math.random() * 6);
                                function tick() {
                                    if (steps-- <= 0) {
                                        span.classList.remove('decoding', 'active', 'has-cursor');
                                        span.classList.add('settled');
                                        span.textContent = targets[i] || '';
                                        settled++;
                                        if (settled === letterSpans.length) resolve();
                                        return;
                                    }

                                    span.textContent = charset.charAt(Math.floor(Math.random() * charset.length));
                                    setTimeout(tick, 20);
                                }
                                tick();
                            }, startDelay);
                        });

                        // safety timeout
                        setTimeout(() => { if (letterSpans.some(s=>s.classList.contains('decoding'))) resolve(); }, 4000);
                    });
                }

                // ---- Slice effect (word-level masked slide) ----
                function animateTitleSliceTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }
                    return new Promise(resolve => {
                        // Transform each .title-word out and slide in new ones
                        if (!el.querySelector('.title-word')) el.innerHTML = toSpannedHTML(el.textContent || '');
                        const words = Array.from(el.querySelectorAll('.title-word'));
                        words.forEach((w, i) => {
                            w.style.transition = 'transform 380ms cubic-bezier(.2,.9,.3,1), opacity 300ms';
                            w.style.transform = 'translateY(-20px) rotateX(-12deg)';
                            w.style.opacity = '0';
                        });
                        const exitDur = 260;
                        setTimeout(() => {
                            el.innerHTML = toSpannedHTML(nextTitle);
                            const newWords = Array.from(el.querySelectorAll('.title-word'));
                            newWords.forEach((w, i) => {
                                w.style.transform = 'translateY(18px) rotateX(30deg)';
                                w.style.opacity = '0';
                                setTimeout(() => {
                                    w.style.transition = 'transform 420ms cubic-bezier(.2,.9,.3,1), opacity 360ms';
                                    w.style.transform = 'translateY(0) rotateX(0)';
                                    w.style.opacity = '1';
                                }, i * 72);
                            });
                            setTimeout(() => resolve(), newWords.length * 72 + 440);
                        }, exitDur);
                    });
                }

                // ---- Particle morph (canvas-based) ----
                function animateTitleParticleTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    // basic particle morph implementation
                    const rect = el.getBoundingClientRect();
                    const canvas = document.createElement('canvas');
                    canvas.className = 'particle-layer';
                    canvas.width = Math.min(1024, Math.ceil(rect.width));
                    canvas.height = Math.min(256, Math.ceil(rect.height));
                    canvas.style.left = rect.left + 'px';
                    canvas.style.top = (rect.top + window.scrollY) + 'px';
                    document.body.appendChild(canvas);
                    const ctx = canvas.getContext('2d');

                    function sampleTextPoints(text) {
                        const tmp = document.createElement('canvas');
                        tmp.width = canvas.width; tmp.height = canvas.height;
                        const tctx = tmp.getContext('2d');
                        tctx.fillStyle = '#fff';
                        const fs = Math.round(canvas.height * 0.72);
                        tctx.font = `${fs}px JetBrains Mono, monospace`;
                        tctx.textAlign = 'left';
                        tctx.textBaseline = 'middle';
                        tctx.clearRect(0,0,tmp.width,tmp.height);
                        tctx.fillText(text, 0, tmp.height/2);
                        const pts = [];
                        const img = tctx.getImageData(0,0,tmp.width,tmp.height);
                        for (let y = 0; y < tmp.height; y+=6) {
                            for (let x = 0; x < tmp.width; x+=6) {
                                const idx = (y*tmp.width + x) * 4 + 3;
                                if (img.data[idx] > 128) pts.push({x, y});
                            }
                        }
                        return pts;
                    }

                    const srcPoints = sampleTextPoints(el.textContent || '');
                    const dstPoints = sampleTextPoints(nextTitle);
                    const N = Math.min(srcPoints.length, dstPoints.length, 1200);
                    const particles = [];
                    for (let i = 0; i < N; i++) {
                        const s = srcPoints[i % srcPoints.length];
                        const d = dstPoints[i % dstPoints.length];
                        particles.push({ x: s.x, y: s.y, tx: d.x, ty: d.y, vx: 0, vy: 0, life: 0 });
                    }

                    // hide title while animating
                    const originalHTML = el.innerHTML;
                    el.style.visibility = 'hidden';

                    const start = performance.now();
                    const dur = 920;
                    function easeOutC(t){ return 1 - Math.pow(1-t, 3); }
                    function tick(now) {
                        const t = Math.min(1, (now - start) / dur);
                        ctx.clearRect(0,0,canvas.width,canvas.height);
                        for (let i = 0; i < particles.length; i++) {
                            const p = particles[i];
                            const ix = p.x + (p.tx - p.x) * easeOutC(t) + (Math.sin((i*7)+t*10)*6*(1-t));
                            const iy = p.y + (p.ty - p.y) * easeOutC(t) + (Math.cos((i*11)+t*8)*4*(1-t));
                            ctx.fillStyle = 'rgba(0,255,136,0.9)';
                            ctx.beginPath(); ctx.arc(ix, iy, 1.5, 0, Math.PI*2); ctx.fill();
                        }
                        if (t < 1) requestAnimationFrame(tick); else {
                            // done
                            document.body.removeChild(canvas);
                            el.innerHTML = nextTitle.replace('\n','<br>');
                            el.style.visibility = '';
                        }
                    }
                    return new Promise(resolve => {
                        requestAnimationFrame(now => {
                            tick(now);
                            setTimeout(() => resolve(), dur + 80);
                        });
                    });
                }

                // ---- CRT type effect ----
                function animateTitleCRTTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    return new Promise(resolve => {
                        el.classList.add('title-crt');
                        const chars = Array.from(nextTitle);
                        el.textContent = '';
                        let i=0;
                        function step(){
                            if (i >= chars.length) { el.classList.remove('title-crt'); resolve(); return; }
                            el.textContent += chars[i];
                            // small flicker effect
                            if (Math.random() < 0.12) el.style.opacity = '0.8'; else el.style.opacity = '1';
                            i++;
                            setTimeout(step, 40 + Math.random()*30);
                        }
                        step();
                    });
                }

                // Production defaults: use decode and disable dev controls
                window._heroTitleEffect = 'decode';

                // --- Auto cycle (re-enabled) ---
                const TITLE_KEY = 'hero_title_idx';
                function getStoredIdx() { return parseInt(localStorage.getItem(TITLE_KEY) || '0', 10) || 0; }
                let titleIdx = getStoredIdx();

                async function cycleTitleStep() {
                    try {
                        titleIdx = (titleIdx + 1) % variants.length;
                        localStorage.setItem(TITLE_KEY, String(titleIdx));
                        console.log('AUTO: cycling to', titleIdx, variants[titleIdx].id);
                        await animateTitleTo(variants[titleIdx].title);
                    } catch (e) { console.warn('AUTO: cycle failed', e); }
                }

                const AUTO_CYCLE_MS = 5200;
                let autoCycleRunning = false;

                // Self-scheduling auto-cycle to avoid overlaps and make timing predictable
                // Robust single-timer scheduler to avoid overlapping cycles
                let autoCycleTimer = null;
                function scheduleNextCycle() {
                    // guard: reduced motion / opt-out
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) { console.log('AUTO: reduced-motion detected — disabled'); return; }
                    if (localStorage.getItem('title_auto_cycle') === '0') { console.log('AUTO: user opt-out detected'); return; }

                    // clear any existing timer just in case
                    if (autoCycleTimer) {
                        clearTimeout(autoCycleTimer);
                        autoCycleTimer = null;
                    }

                    // schedule a single tick; after the animation completes we re-schedule
                    autoCycleTimer = setTimeout(async () => {
                        autoCycleTimer = null;
                        try {
                            await cycleTitleStep();
                        } catch (e) { console.warn('AUTO: cycle failed', e); }

                        // if still running, schedule the next one
                        if (autoCycleRunning) scheduleNextCycle();
                    }, AUTO_CYCLE_MS);
                    console.log('AUTO: scheduled next in', AUTO_CYCLE_MS, 'ms');
                }

                function startAutoCycle() {
                    if (autoCycleRunning) return;
                    autoCycleRunning = true;
                    console.log('AUTO: start');
                    scheduleNextCycle();
                }

                function stopAutoCycle() {
                    if (!autoCycleRunning && !autoCycleTimer) return;
                    console.log('AUTO: stop');
                    autoCycleRunning = false;
                    if (autoCycleTimer) { clearTimeout(autoCycleTimer); autoCycleTimer = null; }
                }

                // Pause while hovering hero
                const heroEl = document.getElementById('hero-copy');
                if (heroEl) { heroEl.addEventListener('mouseenter', stopAutoCycle); heroEl.addEventListener('mouseleave', startAutoCycle); }

                // Start
                startAutoCycle();
            })();
        })();
    </script>
</body>
</html>
